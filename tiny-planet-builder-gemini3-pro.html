<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiny Planet Builder</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        .interactive {
            pointer-events: auto;
        }

        .draggable-item {
            cursor: grab;
            transition: transform 0.1s;
        }

        .draggable-item:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        /* Custom scrollbar for items panel */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
    </style>
    <!-- Import map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body class="bg-sky-300 transition-colors duration-1000 ease-in-out" id="body-bg">

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="flex flex-col justify-between p-4">

        <!-- Top Bar: Controls -->
        <div class="interactive flex justify-between items-start">
            <div class="bg-white/80 backdrop-blur-md p-3 rounded-xl shadow-lg border border-white/50 flex gap-2">
                <button id="toggle-day-night"
                    class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold rounded-lg shadow transition">
                    üåû / üåõ Toggle Day
                </button>
                <button id="btn-clear-weather"
                    class="px-3 py-1.5 bg-blue-400 hover:bg-blue-500 text-white text-sm font-bold rounded-lg shadow transition">
                    ‚òÄÔ∏è Clear
                </button>
                <button id="btn-rain"
                    class="px-3 py-1.5 bg-slate-500 hover:bg-slate-600 text-white text-sm font-bold rounded-lg shadow transition">
                    üåßÔ∏è Rain
                </button>
                <button id="btn-snow"
                    class="px-3 py-1.5 bg-slate-200 hover:bg-slate-300 text-slate-800 text-sm font-bold rounded-lg shadow transition">
                    ‚ùÑÔ∏è Snow
                </button>
                <div class="w-px h-6 bg-white/50 mx-1"></div>
                <button id="toggle-spin"
                    class="px-3 py-1.5 bg-amber-500 hover:bg-amber-600 text-white text-sm font-bold rounded-lg shadow transition">
                    ‚è∏Ô∏è Pause
                </button>
            </div>

            <div
                class="bg-white/80 backdrop-blur-md p-3 rounded-xl shadow-lg border border-white/50 text-slate-700 text-xs font-mono">
                <p>Drag items to planet</p>
                <p>Left Click: Rotate Cam</p>
                <p>Scroll: Zoom</p>
            </div>
        </div>

        <!-- Bottom Bar: Item Dock -->
        <div class="interactive self-center mb-4">
            <div
                class="bg-white/90 backdrop-blur-xl p-4 rounded-2xl shadow-2xl border border-white/60 flex gap-6 items-center overflow-x-auto max-w-[90vw]">

                <div class="draggable-item flex flex-col items-center gap-1 group" draggable="true"
                    data-type="tree_pine">
                    <div
                        class="w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center border-2 border-green-300 group-hover:border-green-500 shadow-sm">
                        üå≤
                    </div>
                    <span class="text-xs font-bold text-slate-600">Pine</span>
                </div>

                <div class="draggable-item flex flex-col items-center gap-1 group" draggable="true"
                    data-type="tree_round">
                    <div
                        class="w-12 h-12 bg-emerald-100 rounded-lg flex items-center justify-center border-2 border-emerald-300 group-hover:border-emerald-500 shadow-sm">
                        üå≥
                    </div>
                    <span class="text-xs font-bold text-slate-600">Oak</span>
                </div>

                <div class="draggable-item flex flex-col items-center gap-1 group" draggable="true"
                    data-type="house_small">
                    <div
                        class="w-12 h-12 bg-orange-100 rounded-lg flex items-center justify-center border-2 border-orange-300 group-hover:border-orange-500 shadow-sm">
                        üè†
                    </div>
                    <span class="text-xs font-bold text-slate-600">Cottage</span>
                </div>

                <div class="draggable-item flex flex-col items-center gap-1 group" draggable="true"
                    data-type="house_tall">
                    <div
                        class="w-12 h-12 bg-red-100 rounded-lg flex items-center justify-center border-2 border-red-300 group-hover:border-red-500 shadow-sm">
                        üè¢
                    </div>
                    <span class="text-xs font-bold text-slate-600">Tower</span>
                </div>

                <div class="draggable-item flex flex-col items-center gap-1 group" draggable="true" data-type="rock">
                    <div
                        class="w-12 h-12 bg-gray-200 rounded-lg flex items-center justify-center border-2 border-gray-400 group-hover:border-gray-600 shadow-sm">
                        ü™®
                    </div>
                    <span class="text-xs font-bold text-slate-600">Rock</span>
                </div>

                <div class="draggable-item flex flex-col items-center gap-1 group" draggable="true" data-type="cloud">
                    <div
                        class="w-12 h-12 bg-blue-50 rounded-lg flex items-center justify-center border-2 border-blue-200 group-hover:border-blue-400 shadow-sm">
                        ‚òÅÔ∏è
                    </div>
                    <span class="text-xs font-bold text-slate-600">Cloud</span>
                </div>

                <div class="w-px h-12 bg-slate-300 mx-2"></div>

                <button id="btn-reset"
                    class="px-3 py-2 bg-red-100 hover:bg-red-200 text-red-600 rounded-lg text-xs font-bold border border-red-200">
                    Reset
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const CONFIG = {
            planetRadius: 10,
            rotationSpeed: 0.001,
            colors: {
                skyDay: '#7dd3fc', // Tailwind sky-300
                skyNight: '#0f172a', // Tailwind slate-900
                planetDay: 0x86efac, // Tailwind green-300
                planetNight: 0x1e293b, // Dark blueish
            }
        };

        // --- State ---
        let isDay = true;
        let weather = 'clear'; // 'clear', 'rain', 'snow'
        let draggedType = null;
        let planetRotationEnabled = true;
        let starOpacity = 0;

        const colorDay = new THREE.Color(CONFIG.colors.skyDay);
        const colorNight = new THREE.Color(CONFIG.colors.skyNight);

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        // Fog helps blend the planet into the background
        scene.fog = new THREE.Fog(colorDay, 20, 60);

        // --- Stars ---
        const starGeo = new THREE.BufferGeometry();
        const starVerts = [];
        for (let i = 0; i < 1000; i++) {
            const x = (Math.random() - 0.5) * 200;
            const y = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            // Keep stars away from center
            if (Math.sqrt(x * x + y * y + z * z) > 40) {
                starVerts.push(x, y, z);
            }
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVerts, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3, transparent: true, opacity: 0 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 35);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.SoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.minDistance = 20;
        controls.maxDistance = 50;
        controls.enableDamping = true;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(20, 30, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 100;
        dirLight.shadow.camera.left = -15;
        dirLight.shadow.camera.right = 15;
        dirLight.shadow.camera.top = 15;
        dirLight.shadow.camera.bottom = -15;
        scene.add(dirLight);

        // --- The Planet ---
        const planetGroup = new THREE.Group();
        scene.add(planetGroup);

        const planetGeometry = new THREE.IcosahedronGeometry(CONFIG.planetRadius, 2); // Low poly look: detail 2
        const planetMaterial = new THREE.MeshStandardMaterial({
            color: CONFIG.colors.planetDay,
            roughness: 0.8,
            metalness: 0.1,
            flatShading: true
        });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        planet.receiveShadow = true;
        planet.name = "planet";
        planetGroup.add(planet);

        // Water/Ocean Core (slightly larger to stick out in low spots if we had noise, but here just a base)
        // Let's add simple "water" chunks or just keep it land for now. Simple is better.

        // --- Object Factory ---
        const materials = {
            wood: new THREE.MeshStandardMaterial({ color: 0x8B4513, flatShading: true }),
            leavesPine: new THREE.MeshStandardMaterial({ color: 0x2E8B57, flatShading: true }),
            leavesRound: new THREE.MeshStandardMaterial({ color: 0x4ADE80, flatShading: true }),
            stone: new THREE.MeshStandardMaterial({ color: 0x94a3b8, flatShading: true }),
            houseWall: new THREE.MeshStandardMaterial({ color: 0xfef08a, flatShading: true }), // Yellowish
            houseRoof: new THREE.MeshStandardMaterial({ color: 0xb91c1c, flatShading: true }), // Red
            cloud: new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true, transparent: true, opacity: 0.9 })
        };

        function createObject(type) {
            const group = new THREE.Group();

            if (type === 'tree_pine') {
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6), materials.wood);
                trunk.position.y = 0.75;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.2, 3, 6), materials.leavesPine);
                leaves.position.y = 2.25;
                leaves.castShadow = true;
                group.add(leaves);
            }
            else if (type === 'tree_round') {
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 1.5, 6), materials.wood);
                trunk.position.y = 0.75;
                trunk.castShadow = true;
                group.add(trunk);

                const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(1.2, 0), materials.leavesRound);
                leaves.position.y = 2.2;
                leaves.castShadow = true;
                group.add(leaves);
            }
            else if (type === 'rock') {
                const geo = new THREE.DodecahedronGeometry(0.8);
                // Randomize slightly
                geo.verticesNeedUpdate = true;
                const rock = new THREE.Mesh(geo, materials.stone);
                rock.position.y = 0.5;
                rock.scale.set(1 + Math.random() * 0.5, 0.8 + Math.random() * 0.4, 1 + Math.random() * 0.5);
                rock.castShadow = true;
                group.add(rock);
            }
            else if (type === 'house_small') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.2, 1.5), materials.houseWall);
                base.position.y = 0.6;
                base.castShadow = true;
                group.add(base);

                const roof = new THREE.Mesh(new THREE.ConeGeometry(1.3, 1, 4), materials.houseRoof);
                roof.position.y = 1.7;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
            }
            else if (type === 'house_tall') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 1.2), materials.houseWall);
                base.position.y = 1;
                base.castShadow = true;
                group.add(base);

                const roof = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.2, 1.4), materials.houseRoof);
                roof.position.y = 2.1;
                roof.castShadow = true;
                group.add(roof);
            }
            else if (type === 'cloud') {
                const c1 = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), materials.cloud);
                const c2 = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), materials.cloud);
                const c3 = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), materials.cloud);
                c1.position.set(0, 0, 0);
                c2.position.set(0.9, 0.1, 0);
                c3.position.set(-0.8, -0.1, 0.2);
                group.add(c1, c2, c3);
                // Clouds float higher
                group.userData.isCloud = true;
            }

            return group;
        }

        function addObjectToPlanet(type, point, normal) {
            const obj = createObject(type);

            // If cloud, calculate height offset
            const heightOffset = obj.userData.isCloud ? 3 + Math.random() * 2 : 0;

            // Position exactly on surface (radius = 10)
            // But dragging gives us a point on the sphere surface.
            // We want to group it inside 'planetGroup' so it rotates.
            // The 'point' from raycaster is in world space. We need to convert to planet local space if planet rotates.
            // But if we simply add to planetGroup, we need local coordinates.

            // To make it easier:
            // 1. Convert world point to local point relative to planetGroup
            const localPoint = planetGroup.worldToLocal(point.clone());

            // Normalize to ensure it's on surface (handling minor raycast errors)
            localPoint.normalize().multiplyScalar(CONFIG.planetRadius + heightOffset);

            obj.position.copy(localPoint);

            // Orient object to face away from center
            obj.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), localPoint.clone().normalize());

            // Random rotation around its own Y axis for variety
            obj.rotateY(Math.random() * Math.PI * 2);

            // Animate pop-in
            const targetScale = obj.scale.clone();
            obj.scale.set(0, 0, 0);
            planetGroup.add(obj);

            let s = 0;
            const animatePop = () => {
                s += 0.1;
                if (s < 1.2) {
                    const scaleVal = Math.min(1, s); // Simple ease out
                    obj.scale.set(scaleVal, scaleVal, scaleVal);
                    requestAnimationFrame(animatePop);
                } else {
                    obj.scale.copy(targetScale);
                }
            };
            animatePop();
        }

        // --- Initial Population ---
        function populatePlanet() {
            for (let i = 0; i < 12; i++) {
                const r = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(CONFIG.planetRadius);
                const worldPos = r.clone().applyMatrix4(planetGroup.matrixWorld); // initial is identity so works
                // Mock raycast result format
                addObjectToPlanet(Math.random() > 0.5 ? 'tree_pine' : 'rock', r, r.clone().normalize());
            }
        }
        populatePlanet();


        // --- Weather System ---
        let particles = null;
        const particleCount = 1500;

        function updateWeather() {
            if (particles) {
                scene.remove(particles);
                particles = null;
            }

            if (weather === 'clear') return;

            const geometry = new THREE.BufferGeometry();
            const vertices = [];

            const spread = 40;
            for (let i = 0; i < particleCount; i++) {
                const x = Math.random() * spread - spread / 2;
                const y = Math.random() * spread - spread / 2 + 10;
                const z = Math.random() * spread - spread / 2;
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            let material;
            if (weather === 'rain') {
                material = new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.8
                });
            } else if (weather === 'snow') {
                material = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 0.2,
                    transparent: true,
                    opacity: 0.9
                });
            }

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function animateWeather() {
            if (!particles) return;

            const positions = particles.geometry.attributes.position.array;
            const fallSpeed = weather === 'rain' ? 0.5 : 0.1;

            for (let i = 1; i < positions.length; i += 3) {
                positions[i] -= fallSpeed;
                if (positions[i] < -15) {
                    positions[i] = 25;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let ghostObject = null;
        const ghostMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.5,
            wireframe: true
        });

        function updateGhost(point, normal) {
            if (!ghostObject && draggedType) {
                ghostObject = createObject(draggedType);
                // Replace materials with ghost material
                ghostObject.traverse((child) => {
                    if (child.isMesh) {
                        child.material = ghostMaterial;
                        child.castShadow = false;
                        child.receiveShadow = false;
                    }
                });
                planetGroup.add(ghostObject);
            }

            if (ghostObject) {
                // Same logic as addObjectToPlanet for positioning
                const localPoint = planetGroup.worldToLocal(point.clone());
                const heightOffset = ghostObject.userData.isCloud ? 3 : 0; // Approx height
                localPoint.normalize().multiplyScalar(CONFIG.planetRadius + heightOffset);
                ghostObject.position.copy(localPoint);
                ghostObject.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), localPoint.clone().normalize());
            }
        }

        function removeGhost() {
            if (ghostObject) {
                planetGroup.remove(ghostObject);
                ghostObject = null;
            }
        }

        // Drag Events
        const draggables = document.querySelectorAll('.draggable-item');
        draggables.forEach(elem => {
            elem.addEventListener('dragstart', (e) => {
                draggedType = e.currentTarget.dataset.type;
                e.dataTransfer.setData('text/plain', draggedType);
                e.dataTransfer.effectAllowed = 'copy';
            });
            elem.addEventListener('dragend', () => {
                draggedType = null;
                removeGhost();
            });
        });

        const canvasContainer = document.getElementById('canvas-container');

        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';

            if (!draggedType) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(planet);

            if (intersects.length > 0) {
                updateGhost(intersects[0].point, intersects[0].face.normal);
            } else {
                removeGhost();
            }
        });

        canvasContainer.addEventListener('dragleave', (e) => {
            // Only remove if we are actually leaving the canvas container, not just hitting a child
            if (e.relatedTarget && !canvasContainer.contains(e.relatedTarget)) {
                removeGhost();
            }
        });

        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            removeGhost(); // Remove ghost before adding real
            if (!draggedType) return;

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObject(planet);

            if (intersects.length > 0) {
                const hit = intersects[0];
                addObjectToPlanet(draggedType, hit.point, hit.face.normal);
            }

            draggedType = null;
        });

        // UI Buttons
        document.getElementById('toggle-spin').addEventListener('click', (e) => {
            planetRotationEnabled = !planetRotationEnabled;
            e.target.innerText = planetRotationEnabled ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            e.target.classList.toggle('bg-amber-500');
            e.target.classList.toggle('bg-emerald-500');
        });

        document.getElementById('toggle-day-night').addEventListener('click', () => {
            isDay = !isDay;
            const bodyBg = document.getElementById('body-bg');

            if (isDay) {
                bodyBg.classList.replace('bg-slate-900', 'bg-sky-300');
                // Fog handled in animate loop
                ambientLight.intensity = 0.6;
                dirLight.intensity = 1.2;
                planetMaterial.color.set(CONFIG.colors.planetDay);
                // Reset lights
                materials.houseWall.emissive.setHex(0x000000);
            } else {
                bodyBg.classList.replace('bg-sky-300', 'bg-slate-900');
                // Fog handled in animate loop
                ambientLight.intensity = 0.2;
                dirLight.intensity = 0.3;
                planetMaterial.color.set(CONFIG.colors.planetNight);
                // Windows light up
                materials.houseWall.emissive.setHex(0xFFAA00);
                materials.houseWall.emissiveIntensity = 0.5;
            }
        });

        document.getElementById('btn-rain').addEventListener('click', () => { weather = 'rain'; updateWeather(); });
        document.getElementById('btn-snow').addEventListener('click', () => { weather = 'snow'; updateWeather(); });
        document.getElementById('btn-clear-weather').addEventListener('click', () => { weather = 'clear'; updateWeather(); });

        document.getElementById('btn-reset').addEventListener('click', () => {
            // Remove all children except the base planet
            // Careful iterating backwards
            for (let i = planetGroup.children.length - 1; i >= 0; i--) {
                if (planetGroup.children[i].name !== 'planet') {
                    planetGroup.remove(planetGroup.children[i]);
                }
            }
            populatePlanet();
        });


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (planetRotationEnabled) {
                planetGroup.rotation.y += CONFIG.rotationSpeed;
            }

            // Animate Stars Opacity
            const targetOpacity = isDay ? 0 : 0.8;
            stars.material.opacity += (targetOpacity - stars.material.opacity) * 0.02;

            // Animate Fog Color
            scene.fog.color.lerp(isDay ? colorDay : colorNight, 0.02);

            controls.update();
            animateWeather();
            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>

</html>