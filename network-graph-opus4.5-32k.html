<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Network Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            overflow: hidden;
        }

        #canvas {
            display: block;
        }
    </style>
</head>

<body class="bg-gray-900 text-white">
    <!-- Controls Panel -->
    <div
        class="absolute top-4 left-4 z-10 bg-gray-800/90 backdrop-blur-sm rounded-xl p-4 shadow-2xl border border-gray-700 w-72">
        <h1 class="text-xl font-bold mb-4 text-cyan-400">Network Graph</h1>

        <!-- Search -->
        <div class="mb-4">
            <label class="block text-sm text-gray-400 mb-1">Search Nodes</label>
            <input type="text" id="searchInput" placeholder="Type to search..."
                class="w-full px-3 py-2 bg-gray-700 rounded-lg border border-gray-600 focus:border-cyan-500 focus:outline-none text-sm">
        </div>

        <!-- Cluster Filter -->
        <div class="mb-4">
            <label class="block text-sm text-gray-400 mb-2">Filter Clusters</label>
            <div id="clusterFilters" class="flex flex-wrap gap-2"></div>
        </div>

        <!-- Controls -->
        <div class="mb-4">
            <label class="block text-sm text-gray-400 mb-2">Physics Controls</label>
            <div class="space-y-2">
                <div class="flex items-center justify-between">
                    <span class="text-xs">Repulsion</span>
                    <input type="range" id="repulsionSlider" min="100" max="1000" value="400"
                        class="w-32 accent-cyan-500">
                </div>
                <div class="flex items-center justify-between">
                    <span class="text-xs">Link Strength</span>
                    <input type="range" id="linkSlider" min="1" max="50" value="20" class="w-32 accent-cyan-500">
                </div>
            </div>
        </div>

        <!-- Buttons -->
        <div class="flex gap-2">
            <button id="resetBtn"
                class="flex-1 px-3 py-2 bg-cyan-600 hover:bg-cyan-500 rounded-lg text-sm font-medium transition">
                Reset View
            </button>
            <button id="shuffleBtn"
                class="flex-1 px-3 py-2 bg-purple-600 hover:bg-purple-500 rounded-lg text-sm font-medium transition">
                Shuffle
            </button>
        </div>
    </div>

    <!-- Legend -->
    <div
        class="absolute bottom-4 left-4 z-10 bg-gray-800/90 backdrop-blur-sm rounded-xl p-4 shadow-2xl border border-gray-700">
        <h3 class="text-sm font-semibold mb-2 text-gray-400">Clusters</h3>
        <div id="legend" class="space-y-1"></div>
    </div>

    <!-- Info Panel -->
    <div id="infoPanel"
        class="absolute top-4 right-4 z-10 bg-gray-800/90 backdrop-blur-sm rounded-xl p-4 shadow-2xl border border-gray-700 w-64 hidden">
        <h3 class="text-lg font-bold text-cyan-400" id="nodeTitle">Node Info</h3>
        <p class="text-sm text-gray-400 mt-1" id="nodeCluster">Cluster: -</p>
        <p class="text-sm text-gray-400" id="nodeConnections">Connections: -</p>
    </div>

    <!-- Zoom Controls -->
    <div class="absolute bottom-4 right-4 z-10 flex flex-col gap-2">
        <button id="zoomIn"
            class="w-10 h-10 bg-gray-800/90 hover:bg-gray-700 rounded-lg border border-gray-700 text-xl font-bold transition">+</button>
        <button id="zoomOut"
            class="w-10 h-10 bg-gray-800/90 hover:bg-gray-700 rounded-lg border border-gray-700 text-xl font-bold transition">âˆ’</button>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Cluster definitions
        const clusters = [
            { id: 0, name: 'Technology', color: '#06b6d4' },
            { id: 1, name: 'Science', color: '#8b5cf6' },
            { id: 2, name: 'Business', color: '#10b981' },
            { id: 3, name: 'Arts', color: '#f59e0b' },
            { id: 4, name: 'Social', color: '#ef4444' }
        ];

        const clusterVisibility = clusters.map(() => true);

        // Generate network data
        function generateNetwork() {
            const nodes = [];
            const edges = [];

            // Create nodes
            const nodeNames = [
                'AI', 'Machine Learning', 'Cloud', 'Blockchain', 'IoT', 'Cybersecurity', 'DevOps', 'API',
                'Physics', 'Chemistry', 'Biology', 'Mathematics', 'Astronomy', 'Geology', 'Ecology',
                'Marketing', 'Finance', 'Strategy', 'Sales', 'HR', 'Operations', 'Analytics',
                'Music', 'Film', 'Design', 'Photography', 'Writing', 'Animation', 'Theater',
                'Community', 'Education', 'Healthcare', 'Environment', 'Politics', 'Media', 'Sports'
            ];

            nodeNames.forEach((name, i) => {
                const clusterId = Math.floor(i / 7) % 5;
                nodes.push({
                    id: i,
                    name: name,
                    cluster: clusterId,
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: 0,
                    vy: 0,
                    radius: 8 + Math.random() * 12
                });
            });

            // Create edges - connect nodes within and across clusters
            nodes.forEach((node, i) => {
                // Connect to 2-4 nodes in same cluster
                const sameCluster = nodes.filter(n => n.cluster === node.cluster && n.id !== node.id);
                const numConnections = 2 + Math.floor(Math.random() * 3);
                for (let j = 0; j < Math.min(numConnections, sameCluster.length); j++) {
                    const target = sameCluster[Math.floor(Math.random() * sameCluster.length)];
                    if (!edges.find(e => (e.source === node.id && e.target === target.id) || (e.source === target.id && e.target === node.id))) {
                        edges.push({ source: node.id, target: target.id, strength: 0.8 });
                    }
                }

                // Connect to 0-2 nodes in different clusters
                if (Math.random() > 0.5) {
                    const diffCluster = nodes.filter(n => n.cluster !== node.cluster);
                    const target = diffCluster[Math.floor(Math.random() * diffCluster.length)];
                    if (!edges.find(e => (e.source === node.id && e.target === target.id) || (e.source === target.id && e.target === node.id))) {
                        edges.push({ source: node.id, target: target.id, strength: 0.3 });
                    }
                }
            });

            return { nodes, edges };
        }

        let { nodes, edges } = generateNetwork();

        // View state
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let dragNode = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let hoveredNode = null;
        let searchQuery = '';

        // Physics settings
        let repulsionForce = 400;
        let linkStrength = 20;

        // Transform functions
        function screenToWorld(sx, sy) {
            return {
                x: (sx - panX) / zoom,
                y: (sy - panY) / zoom
            };
        }

        function worldToScreen(wx, wy) {
            return {
                x: wx * zoom + panX,
                y: wy * zoom + panY
            };
        }

        // Physics simulation
        function simulate() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Apply forces to each node
            nodes.forEach(node => {
                if (!clusterVisibility[node.cluster]) return;

                // Center gravity
                node.vx += (centerX - node.x) * 0.0001;
                node.vy += (centerY - node.y) * 0.0001;

                // Cluster gravity
                const clusterNodes = nodes.filter(n => n.cluster === node.cluster && clusterVisibility[n.cluster]);
                const clusterCenter = {
                    x: clusterNodes.reduce((sum, n) => sum + n.x, 0) / clusterNodes.length,
                    y: clusterNodes.reduce((sum, n) => sum + n.y, 0) / clusterNodes.length
                };
                node.vx += (clusterCenter.x - node.x) * 0.001;
                node.vy += (clusterCenter.y - node.y) * 0.001;

                // Repulsion from other nodes
                nodes.forEach(other => {
                    if (other.id === node.id || !clusterVisibility[other.cluster]) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    const force = repulsionForce / (dist * dist);

                    node.vx += (dx / dist) * force;
                    node.vy += (dy / dist) * force;
                });
            });

            // Apply edge forces
            edges.forEach(edge => {
                const source = nodes[edge.source];
                const target = nodes[edge.target];

                if (!clusterVisibility[source.cluster] || !clusterVisibility[target.cluster]) return;

                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                const force = (dist - linkStrength * 5) * 0.01 * edge.strength;

                source.vx += (dx / dist) * force;
                source.vy += (dy / dist) * force;
                target.vx -= (dx / dist) * force;
                target.vy -= (dy / dist) * force;
            });

            // Update positions
            nodes.forEach(node => {
                if (node === dragNode) return;

                node.vx *= 0.9; // Damping
                node.vy *= 0.9;
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        // Render
        function render() {
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(zoom, zoom);

            // Draw edges
            edges.forEach(edge => {
                const source = nodes[edge.source];
                const target = nodes[edge.target];

                if (!clusterVisibility[source.cluster] || !clusterVisibility[target.cluster]) return;

                const isHighlighted = searchQuery &&
                    (source.name.toLowerCase().includes(searchQuery) ||
                        target.name.toLowerCase().includes(searchQuery));

                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.strokeStyle = isHighlighted ? '#ffffff' : `rgba(255,255,255,${0.1 + edge.strength * 0.1})`;
                ctx.lineWidth = isHighlighted ? 2 / zoom : 1 / zoom;
                ctx.stroke();
            });

            // Draw nodes
            nodes.forEach(node => {
                if (!clusterVisibility[node.cluster]) return;

                const isSearchMatch = searchQuery && node.name.toLowerCase().includes(searchQuery);
                const isHovered = node === hoveredNode;

                // Glow effect for highlighted nodes
                if (isSearchMatch || isHovered) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius + 8, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(node.x, node.y, node.radius, node.x, node.y, node.radius + 8);
                    gradient.addColorStop(0, clusters[node.cluster].color);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }

                // Node circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fillStyle = isSearchMatch ? '#ffffff' : clusters[node.cluster].color;
                ctx.fill();

                if (isHovered || isSearchMatch) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3 / zoom;
                    ctx.stroke();
                }

                // Node label
                if (zoom > 0.5 || isHovered || isSearchMatch) {
                    ctx.font = `${Math.max(10, 12 / zoom)}px system-ui, sans-serif`;
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.name, node.x, node.y + node.radius + 15 / zoom);
                }
            });

            ctx.restore();
        }

        // Animation loop
        function animate() {
            simulate();
            render();
            requestAnimationFrame(animate);
        }

        // Event handlers
        canvas.addEventListener('mousedown', (e) => {
            const world = screenToWorld(e.clientX, e.clientY);

            // Check if clicking on a node
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (!clusterVisibility[node.cluster]) continue;

                const dx = world.x - node.x;
                const dy = world.y - node.y;
                if (Math.sqrt(dx * dx + dy * dy) < node.radius) {
                    dragNode = node;
                    break;
                }
            }

            if (!dragNode) {
                isDragging = true;
            }
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            const world = screenToWorld(e.clientX, e.clientY);

            if (dragNode) {
                dragNode.x = world.x;
                dragNode.y = world.y;
                dragNode.vx = 0;
                dragNode.vy = 0;
            } else if (isDragging) {
                panX += e.clientX - lastMouseX;
                panY += e.clientY - lastMouseY;
            } else {
                // Hover detection
                hoveredNode = null;
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    if (!clusterVisibility[node.cluster]) continue;

                    const dx = world.x - node.x;
                    const dy = world.y - node.y;
                    if (Math.sqrt(dx * dx + dy * dy) < node.radius) {
                        hoveredNode = node;
                        break;
                    }
                }

                // Update info panel
                const infoPanel = document.getElementById('infoPanel');
                if (hoveredNode) {
                    infoPanel.classList.remove('hidden');
                    document.getElementById('nodeTitle').textContent = hoveredNode.name;
                    document.getElementById('nodeCluster').textContent = `Cluster: ${clusters[hoveredNode.cluster].name}`;
                    const connections = edges.filter(e => e.source === hoveredNode.id || e.target === hoveredNode.id).length;
                    document.getElementById('nodeConnections').textContent = `Connections: ${connections}`;
                } else {
                    infoPanel.classList.add('hidden');
                }
            }

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = hoveredNode || dragNode ? 'grab' : 'default';
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragNode = null;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Zoom toward mouse position
            panX = mouseX - (mouseX - panX) * zoomFactor;
            panY = mouseY - (mouseY - panY) * zoomFactor;
            zoom *= zoomFactor;
            zoom = Math.max(0.1, Math.min(5, zoom));
        });

        // UI Controls
        document.getElementById('searchInput').addEventListener('input', (e) => {
            searchQuery = e.target.value.toLowerCase();
        });

        document.getElementById('repulsionSlider').addEventListener('input', (e) => {
            repulsionForce = parseInt(e.target.value);
        });

        document.getElementById('linkSlider').addEventListener('input', (e) => {
            linkStrength = parseInt(e.target.value);
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            zoom = 1;
            panX = 0;
            panY = 0;
        });

        document.getElementById('shuffleBtn').addEventListener('click', () => {
            nodes.forEach(node => {
                node.x = Math.random() * canvas.width;
                node.y = Math.random() * canvas.height;
                node.vx = 0;
                node.vy = 0;
            });
        });

        document.getElementById('zoomIn').addEventListener('click', () => {
            zoom = Math.min(5, zoom * 1.2);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            zoom = Math.max(0.1, zoom * 0.8);
        });

        // Build cluster filters
        const filtersContainer = document.getElementById('clusterFilters');
        const legendContainer = document.getElementById('legend');

        clusters.forEach((cluster, i) => {
            // Filter button
            const btn = document.createElement('button');
            btn.className = 'px-2 py-1 rounded text-xs font-medium transition';
            btn.style.backgroundColor = cluster.color;
            btn.textContent = cluster.name;
            btn.addEventListener('click', () => {
                clusterVisibility[i] = !clusterVisibility[i];
                btn.style.opacity = clusterVisibility[i] ? 1 : 0.3;
            });
            filtersContainer.appendChild(btn);

            // Legend item
            const legendItem = document.createElement('div');
            legendItem.className = 'flex items-center gap-2';
            legendItem.innerHTML = `
                <span class="w-3 h-3 rounded-full" style="background-color: ${cluster.color}"></span>
                <span class="text-xs">${cluster.name}</span>
            `;
            legendContainer.appendChild(legendItem);
        });

        // Start animation
        animate();
    </script>
</body>

</html>