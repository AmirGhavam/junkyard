<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>2048 â€“ Modern Web Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        :root {
            color-scheme: dark;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Inter", ui-sans-serif, sans-serif;
        }

        .cell-bg {
            width: 100%;
            height: 100%;
            border-radius: 0.9rem;
            background: radial-gradient(circle at 0% 0%, rgba(148, 163, 184, 0.28), transparent 55%), #020617;
            box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.95);
        }

        .tile {
            width: 100%;
            height: 100%;
            border-radius: 0.9rem;
            font-variant-numeric: tabular-nums;
            font-weight: 800;
            font-size: clamp(1.4rem, 4vw, 2.4rem);
            transition: transform 0.12s ease-out, background 0.18s ease-out, box-shadow 0.18s ease-out;
            background: rgba(15, 23, 42, 0.85);
            color: #e5e7eb;
            box-shadow: 0 12px 25px rgba(15, 23, 42, 0.75);
            user-select: none;
        }

        .tile-empty {
            background: rgba(15, 23, 42, 0.88);
            color: transparent;
            box-shadow: none;
        }

        .tile-2 {
            background: linear-gradient(135deg, #e5e7eb, #f9fafb);
            color: #111827;
        }

        .tile-4 {
            background: linear-gradient(135deg, #e0f2fe, #bfdbfe);
            color: #0f172a;
        }

        .tile-8 {
            background: linear-gradient(135deg, #fed7aa, #fdba74);
            color: #7c2d12;
        }

        .tile-16 {
            background: linear-gradient(135deg, #fdba74, #fb923c);
            color: #7c2d12;
        }

        .tile-32 {
            background: linear-gradient(135deg, #f97316, #ea580c);
            color: #111827;
        }

        .tile-64 {
            background: linear-gradient(135deg, #f97316, #dc2626);
            color: #f9fafb;
        }

        .tile-128 {
            background: linear-gradient(135deg, #facc15, #eab308);
            color: #1f2937;
        }

        .tile-256 {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #022c22;
        }

        .tile-512 {
            background: linear-gradient(135deg, #2dd4bf, #14b8a6);
            color: #022c22;
        }

        .tile-1024 {
            background: linear-gradient(135deg, #38bdf8, #0ea5e9);
            color: #0b1120;
        }

        .tile-2048 {
            background: linear-gradient(135deg, #f97316, #facc15);
            color: #0b1120;
            box-shadow: 0 0 0 1px rgba(248, 250, 252, 0.7), 0 18px 45px rgba(234, 179, 8, 0.55);
        }

        .tile-super {
            background: linear-gradient(135deg, #818cf8, #a855f7, #ec4899);
            color: #f9fafb;
            box-shadow: 0 0 0 1px rgba(248, 250, 252, 0.6), 0 22px 55px rgba(129, 140, 248, 0.6);
        }

        @keyframes tile-pop {
            0% {
                transform: scale(0.4);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .tile-new {
            animation: tile-pop 0.16s ease-out;
        }
    </style>
</head>

<body
    class="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950 text-slate-100 flex items-center justify-center p-4">
    <div class="w-full max-w-md space-y-4 sm:space-y-6">
        <header class="flex items-end justify-between gap-4">
            <div>
                <div class="flex items-baseline gap-2">
                    <h1 class="text-4xl sm:text-5xl font-black tracking-tight">2048</h1>
                    <span
                        class="rounded-full bg-emerald-500/10 border border-emerald-500/30 text-emerald-300 text-[0.65rem] px-2 py-0.5 uppercase tracking-[0.18em]">Modern</span>
                </div>
                <p class="mt-1 text-sm text-slate-400">
                    Join the tiles. Get to <span class="font-semibold text-amber-300">2048</span>.
                </p>
            </div>
            <div class="flex gap-2 sm:gap-3">
                <div
                    class="bg-slate-900/70 rounded-xl px-3 py-2 min-w-[4.5rem] text-right shadow-inner border border-slate-700/80">
                    <p class="text-[0.65rem] uppercase tracking-[0.16em] text-slate-400">Score</p>
                    <p id="score" class="mt-0.5 text-lg font-bold tabular-nums">0</p>
                </div>
                <div
                    class="bg-slate-900/70 rounded-xl px-3 py-2 min-w-[4.5rem] text-right shadow-inner border border-slate-700/80">
                    <p class="text-[0.65rem] uppercase tracking-[0.16em] text-slate-400">Best</p>
                    <p id="best-score" class="mt-0.5 text-lg font-bold tabular-nums">0</p>
                </div>
            </div>
        </header>

        <div class="flex items-center justify-between text-xs text-slate-400">
            <p>
                Use <span class="font-semibold text-slate-200">arrow keys</span> or
                <span class="font-semibold text-slate-200">swipe</span>.
            </p>
            <button id="new-game"
                class="inline-flex items-center gap-1 rounded-full border border-emerald-500/60 bg-emerald-500/15 px-3 py-1 text-[0.7rem] font-semibold text-emerald-200 hover:bg-emerald-500/25 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-400 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950">
                New game
            </button>
        </div>

        <main id="game-container" class="bg-slate-900/70 rounded-3xl p-3 sm:p-4 shadow-xl border border-slate-700/80">
            <div class="relative aspect-square rounded-2xl bg-slate-950/80 overflow-hidden">
                <!-- Board background cells -->
                <div class="absolute inset-3 sm:inset-4 grid grid-cols-4 gap-3 sm:gap-4">
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                    <div class="cell-bg"></div>
                </div>

                <!-- Tiles layer -->
                <div id="tile-layer" class="absolute inset-3 sm:inset-4 grid grid-cols-4 gap-3 sm:gap-4">
                    <div id="cell-0-0" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-0-1" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-0-2" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-0-3" data-cell class="tile flex items-center justify-center"></div>

                    <div id="cell-1-0" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-1-1" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-1-2" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-1-3" data-cell class="tile flex items-center justify-center"></div>

                    <div id="cell-2-0" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-2-1" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-2-2" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-2-3" data-cell class="tile flex items-center justify-center"></div>

                    <div id="cell-3-0" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-3-1" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-3-2" data-cell class="tile flex items-center justify-center"></div>
                    <div id="cell-3-3" data-cell class="tile flex items-center justify-center"></div>
                </div>

                <!-- Game over overlay -->
                <div id="game-over-overlay"
                    class="absolute inset-0 flex items-center justify-center rounded-2xl bg-slate-950/80 hidden opacity-0 transition-opacity duration-200">
                    <div class="text-center space-y-3 px-4">
                        <p class="text-xs uppercase tracking-[0.18em] text-slate-400">
                            Game over
                        </p>
                        <p class="text-2xl sm:text-3xl font-black text-slate-50">
                            No more moves
                        </p>
                        <button id="try-again"
                            class="mt-1 inline-flex items-center justify-center rounded-full bg-emerald-500 px-4 py-2 text-sm font-semibold text-slate-950 shadow-lg shadow-emerald-500/40 hover:bg-emerald-400 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-300 focus-visible:ring-offset-2 focus-visible:ring-offset-slate-950 transition-colors">
                            Try again
                        </button>
                    </div>
                </div>
            </div>
        </main>

        <p class="text-[0.7rem] text-slate-500 text-center leading-relaxed">
            Built with vanilla JavaScript. Your best score is stored locally in this browser.
        </p>
    </div>

    <script>
        (function () {
            const size = 4;
            let board = [];
            let score = 0;
            let bestScore = 0;
            let gameOver = false;
            const BEST_KEY = "modern-2048-best";

            function cacheBaseClasses() {
                const tiles = document.querySelectorAll("[data-cell]");
                tiles.forEach((tile) => {
                    tile.dataset.base = tile.className;
                });
            }

            function getTileClass(value) {
                if (value === 0) return "tile-empty";
                if (value === 2) return "tile-2";
                if (value === 4) return "tile-4";
                if (value === 8) return "tile-8";
                if (value === 16) return "tile-16";
                if (value === 32) return "tile-32";
                if (value === 64) return "tile-64";
                if (value === 128) return "tile-128";
                if (value === 256) return "tile-256";
                if (value === 512) return "tile-512";
                if (value === 1024) return "tile-1024";
                if (value === 2048) return "tile-2048";
                return "tile-super";
            }

            function updateBoardView() {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const value = board[r][c];
                        const tile = document.getElementById(`cell-${r}-${c}`);
                        if (!tile) continue;
                        const base = tile.dataset.base || "tile flex items-center justify-center";
                        tile.className = base + " " + getTileClass(value);
                        tile.textContent = value === 0 ? "" : String(value);
                    }
                }
            }

            function loadBestScore() {
                try {
                    const stored = localStorage.getItem(BEST_KEY);
                    if (stored) {
                        const parsed = parseInt(stored, 10);
                        if (!Number.isNaN(parsed)) {
                            bestScore = parsed;
                        }
                    }
                } catch (e) {
                    bestScore = 0;
                }
                const bestEl = document.getElementById("best-score");
                if (bestEl) bestEl.textContent = String(bestScore);
            }

            function updateScoreUI() {
                const scoreEl = document.getElementById("score");
                const bestEl = document.getElementById("best-score");
                if (scoreEl) scoreEl.textContent = String(score);
                if (score > bestScore) {
                    bestScore = score;
                    try {
                        localStorage.setItem(BEST_KEY, String(bestScore));
                    } catch (e) {
                        // ignore storage errors
                    }
                }
                if (bestEl) bestEl.textContent = String(bestScore);
            }

            function getEmptyCells() {
                const empty = [];
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (board[r][c] === 0) empty.push({ row: r, col: c });
                    }
                }
                return empty;
            }

            function addRandomTile() {
                const empty = getEmptyCells();
                if (empty.length === 0) return null;
                const { row, col } = empty[Math.floor(Math.random() * empty.length)];
                const value = Math.random() < 0.9 ? 2 : 4;
                board[row][col] = value;
                return { row, col, value };
            }

            function boardsEqual(a, b) {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (a[r][c] !== b[r][c]) return false;
                    }
                }
                return true;
            }

            function slideAndMerge(line) {
                const filtered = line.filter((v) => v !== 0);
                const result = [];
                let i = 0;
                while (i < filtered.length) {
                    if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
                        const merged = filtered[i] * 2;
                        result.push(merged);
                        score += merged;
                        i += 2;
                    } else {
                        result.push(filtered[i]);
                        i += 1;
                    }
                }
                while (result.length < size) {
                    result.push(0);
                }
                return result;
            }

            function isGameOver() {
                // Any empty cell?
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (board[r][c] === 0) return false;
                    }
                }
                // Any possible merge?
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        const value = board[r][c];
                        if (r + 1 < size && board[r + 1][c] === value) return false;
                        if (c + 1 < size && board[r][c + 1] === value) return false;
                    }
                }
                return true;
            }

            function showGameOver() {
                const overlay = document.getElementById("game-over-overlay");
                if (!overlay) return;
                overlay.classList.remove("hidden", "opacity-0");
                overlay.classList.add("opacity-100");
            }

            function hideGameOver() {
                const overlay = document.getElementById("game-over-overlay");
                if (!overlay) return;
                overlay.classList.add("hidden", "opacity-0");
                overlay.classList.remove("opacity-100");
            }

            function animateTile(row, col, type = "tile-new") {
                const tile = document.getElementById(`cell-${row}-${col}`);
                if (!tile) return;
                tile.classList.remove("tile-new");
                // Force reflow to restart animation
                void tile.offsetWidth;
                tile.classList.add(type);
                setTimeout(() => {
                    tile.classList.remove(type);
                }, 180);
            }

            function move(direction) {
                if (gameOver) return;
                const prevBoard = board.map((row) => row.slice());

                if (direction === "left") {
                    for (let r = 0; r < size; r++) {
                        board[r] = slideAndMerge(board[r]);
                    }
                } else if (direction === "right") {
                    for (let r = 0; r < size; r++) {
                        const reversed = board[r].slice().reverse();
                        const merged = slideAndMerge(reversed).reverse();
                        board[r] = merged;
                    }
                } else if (direction === "up") {
                    for (let c = 0; c < size; c++) {
                        const column = [];
                        for (let r = 0; r < size; r++) column.push(board[r][c]);
                        const merged = slideAndMerge(column);
                        for (let r = 0; r < size; r++) board[r][c] = merged[r];
                    }
                } else if (direction === "down") {
                    for (let c = 0; c < size; c++) {
                        const column = [];
                        for (let r = 0; r < size; r++) column.push(board[r][c]);
                        const merged = slideAndMerge(column.reverse()).reverse();
                        for (let r = 0; r < size; r++) board[r][c] = merged[r];
                    }
                } else {
                    return;
                }

                const moved = !boardsEqual(prevBoard, board);
                if (!moved) return;

                const added = addRandomTile();
                updateBoardView();
                if (added) animateTile(added.row, added.col, "tile-new");
                updateScoreUI();

                if (isGameOver()) {
                    gameOver = true;
                    showGameOver();
                }
            }

            function newGame() {
                board = Array.from({ length: size }, () => Array(size).fill(0));
                score = 0;
                gameOver = false;
                hideGameOver();
                const first = addRandomTile();
                const second = addRandomTile();
                updateBoardView();
                if (first) animateTile(first.row, first.col, "tile-new");
                if (second) animateTile(second.row, second.col, "tile-new");
                updateScoreUI();
            }

            function handleKeydown(event) {
                const key = event.key;
                let direction = null;
                if (key === "ArrowUp" || key === "w" || key === "W") direction = "up";
                else if (key === "ArrowDown" || key === "s" || key === "S") direction = "down";
                else if (key === "ArrowLeft" || key === "a" || key === "A") direction = "left";
                else if (key === "ArrowRight" || key === "d" || key === "D") direction = "right";

                if (!direction) return;
                event.preventDefault();
                move(direction);
            }

            function setupControls() {
                document.addEventListener("keydown", handleKeydown);

                const newGameButton = document.getElementById("new-game");
                const tryAgainButton = document.getElementById("try-again");

                if (newGameButton) newGameButton.addEventListener("click", newGame);
                if (tryAgainButton) tryAgainButton.addEventListener("click", newGame);

                const container = document.getElementById("game-container");
                if (!container) return;

                let touchStartX = 0;
                let touchStartY = 0;

                container.addEventListener(
                    "touchstart",
                    (event) => {
                        if (event.touches.length > 1) return;
                        const touch = event.touches[0];
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                    },
                    { passive: true }
                );

                container.addEventListener(
                    "touchend",
                    (event) => {
                        if (event.changedTouches.length === 0) return;
                        const touch = event.changedTouches[0];
                        const dx = touch.clientX - touchStartX;
                        const dy = touch.clientY - touchStartY;
                        const absX = Math.abs(dx);
                        const absY = Math.abs(dy);
                        const threshold = 24;

                        if (Math.max(absX, absY) < threshold) return;

                        if (absX > absY) {
                            move(dx > 0 ? "right" : "left");
                        } else {
                            move(dy > 0 ? "down" : "up");
                        }
                    },
                    { passive: true }
                );
            }

            window.addEventListener("DOMContentLoaded", () => {
                cacheBaseClasses();
                loadBestScore();
                setupControls();
                newGame();
            });
        })();
    </script>
</body>

</html>