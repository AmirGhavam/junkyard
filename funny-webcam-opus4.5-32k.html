<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funny Webcam Filters</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        .filter-btn.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .filter-btn:hover {
            transform: translateY(-2px);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .recording {
            animation: pulse 1s infinite;
        }
    </style>
</head>

<body class="bg-gradient-to-br from-purple-900 via-indigo-900 to-blue-900 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white mb-2">
                üé≠ Funny Webcam Filters
            </h1>
            <p class="text-purple-200 text-lg">Transform yourself with hilarious real-time effects!</p>
        </header>

        <!-- Main Content -->
        <div class="flex flex-col lg:flex-row gap-8 items-start justify-center">
            <!-- Video Container -->
            <div class="relative">
                <div class="bg-black rounded-2xl overflow-hidden shadow-2xl border-4 border-purple-500/50">
                    <video id="video" class="hidden" autoplay playsinline></video>
                    <canvas id="canvas" class="w-full max-w-xl"></canvas>

                    <!-- Overlay when no camera -->
                    <div id="placeholder"
                        class="w-full max-w-xl h-80 md:h-96 flex flex-col items-center justify-center bg-gray-800">
                        <span class="text-6xl mb-4">üì∑</span>
                        <p class="text-gray-400 text-lg">Click "Start Camera" to begin</p>
                    </div>
                </div>

                <!-- Camera Controls -->
                <div class="flex gap-4 justify-center mt-4">
                    <button id="startBtn" onclick="startCamera()"
                        class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full transition-all flex items-center gap-2">
                        <span>üìπ</span> Start Camera
                    </button>
                    <button id="stopBtn" onclick="stopCamera()"
                        class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full transition-all flex items-center gap-2 hidden">
                        <span>‚èπÔ∏è</span> Stop
                    </button>
                    <button onclick="takePhoto()"
                        class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full transition-all flex items-center gap-2">
                        <span>üì∏</span> Snapshot
                    </button>
                </div>
            </div>

            <!-- Filters Panel -->
            <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 w-full lg:w-80">
                <h2 class="text-2xl font-bold text-white mb-4 flex items-center gap-2">
                    <span>‚ú®</span> Filters
                </h2>
                <div id="filters" class="grid grid-cols-2 gap-3">
                    <!-- Filters will be inserted here -->
                </div>
            </div>
        </div>

        <!-- Snapshots Gallery -->
        <div id="gallery" class="mt-8 hidden">
            <h2 class="text-2xl font-bold text-white mb-4 text-center">üì∏ Your Snapshots</h2>
            <div id="snapshots" class="flex flex-wrap gap-4 justify-center">
            </div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const placeholder = document.getElementById('placeholder');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const filtersContainer = document.getElementById('filters');
        const gallery = document.getElementById('gallery');
        const snapshots = document.getElementById('snapshots');

        let stream = null;
        let currentFilter = 'normal';
        let animationId = null;

        // Filter definitions
        const filters = [
            { id: 'normal', name: 'Normal', emoji: 'üòä' },
            { id: 'grayscale', name: 'B&W', emoji: 'üñ§' },
            { id: 'sepia', name: 'Vintage', emoji: 'üìú' },
            { id: 'invert', name: 'Invert', emoji: 'üîÑ' },
            { id: 'mirror', name: 'Mirror', emoji: 'ü™û' },
            { id: 'pixelate', name: 'Pixel', emoji: 'üëæ' },
            { id: 'rainbow', name: 'Rainbow', emoji: 'üåà' },
            { id: 'glitch', name: 'Glitch', emoji: 'üì∫' },
            { id: 'fisheye', name: 'Fisheye', emoji: 'üêü' },
            { id: 'posterize', name: 'Poster', emoji: 'üé®' },
            { id: 'thermal', name: 'Thermal', emoji: 'üî•' },
            { id: 'xray', name: 'X-Ray', emoji: '‚ò†Ô∏è' },
            { id: 'emboss', name: 'Emboss', emoji: 'üóø' },
            { id: 'duotone', name: 'Duotone', emoji: 'üíú' },
            { id: 'vhs', name: 'VHS', emoji: 'üìº' },
            { id: 'drunk', name: 'Dizzy', emoji: 'ü•¥' },
        ];

        // Create filter buttons
        filters.forEach(filter => {
            const btn = document.createElement('button');
            btn.className = `filter-btn bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-semibold py-3 px-4 rounded-xl transition-all duration-200 ${filter.id === 'normal' ? 'active ring-2 ring-white' : ''}`;
            btn.innerHTML = `<span class="text-xl">${filter.emoji}</span><br><span class="text-xs">${filter.name}</span>`;
            btn.onclick = () => setFilter(filter.id);
            btn.id = `filter-${filter.id}`;
            filtersContainer.appendChild(btn);
        });

        function setFilter(filterId) {
            currentFilter = filterId;
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active', 'ring-2', 'ring-white');
            });
            document.getElementById(`filter-${filterId}`).classList.add('active', 'ring-2', 'ring-white');
        }

        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;
                await video.play();

                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                placeholder.classList.add('hidden');
                startBtn.classList.add('hidden');
                stopBtn.classList.remove('hidden');

                render();
            } catch (err) {
                alert('Could not access camera. Please allow camera permissions.');
                console.error(err);
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            placeholder.classList.remove('hidden');
            startBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function render() {
            ctx.drawImage(video, 0, 0);
            applyFilter(currentFilter);
            animationId = requestAnimationFrame(render);
        }

        function applyFilter(filter) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            switch (filter) {
                case 'grayscale':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = data[i + 1] = data[i + 2] = avg;
                    }
                    break;

                case 'sepia':
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i + 1], b = data[i + 2];
                        data[i] = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
                        data[i + 1] = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
                        data[i + 2] = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
                    }
                    break;

                case 'invert':
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = 255 - data[i];
                        data[i + 1] = 255 - data[i + 1];
                        data[i + 2] = 255 - data[i + 2];
                    }
                    break;

                case 'mirror':
                    ctx.save();
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, -canvas.width, 0);
                    ctx.restore();
                    return;

                case 'pixelate':
                    const size = 10;
                    for (let y = 0; y < canvas.height; y += size) {
                        for (let x = 0; x < canvas.width; x += size) {
                            const i = (y * canvas.width + x) * 4;
                            ctx.fillStyle = `rgb(${data[i]},${data[i + 1]},${data[i + 2]})`;
                            ctx.fillRect(x, y, size, size);
                        }
                    }
                    return;

                case 'rainbow':
                    const time = Date.now() * 0.002;
                    for (let i = 0; i < data.length; i += 4) {
                        const x = (i / 4) % canvas.width;
                        const hueShift = (x / canvas.width + time) * 360;
                        data[i] = (data[i] + hueShift) % 256;
                        data[i + 1] = (data[i + 1] + hueShift * 0.5) % 256;
                    }
                    break;

                case 'glitch':
                    const offset = Math.random() * 20 - 10;
                    for (let y = 0; y < canvas.height; y++) {
                        if (Math.random() > 0.95) {
                            const glitchOffset = Math.floor(Math.random() * 30 - 15);
                            for (let x = 0; x < canvas.width; x++) {
                                const srcIdx = (y * canvas.width + x) * 4;
                                const dstX = Math.max(0, Math.min(canvas.width - 1, x + glitchOffset));
                                const dstIdx = (y * canvas.width + dstX) * 4;
                                data[dstIdx] = data[srcIdx];
                            }
                        }
                    }
                    // RGB split
                    for (let i = 0; i < data.length; i += 4) {
                        const shift = Math.floor(offset) * 4;
                        if (i + shift < data.length && i + shift >= 0) {
                            data[i] = data[i + shift] || data[i];
                        }
                    }
                    break;

                case 'fisheye':
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.putImageData(imageData, 0, 0);

                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const radius = Math.min(centerX, centerY);

                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const dx = x - centerX;
                            const dy = y - centerY;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < radius) {
                                const factor = Math.pow(Math.sin(Math.PI * dist / radius / 2), 0.7);
                                const srcX = Math.floor(centerX + dx * factor);
                                const srcY = Math.floor(centerY + dy * factor);

                                const srcIdx = (srcY * canvas.width + srcX) * 4;
                                const dstIdx = (y * canvas.width + x) * 4;

                                data[dstIdx] = data[srcIdx];
                                data[dstIdx + 1] = data[srcIdx + 1];
                                data[dstIdx + 2] = data[srcIdx + 2];
                            }
                        }
                    }
                    break;

                case 'posterize':
                    const levels = 4;
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.floor(data[i] / (256 / levels)) * (256 / levels);
                        data[i + 1] = Math.floor(data[i + 1] / (256 / levels)) * (256 / levels);
                        data[i + 2] = Math.floor(data[i + 2] / (256 / levels)) * (256 / levels);
                    }
                    break;

                case 'thermal':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        if (avg < 64) {
                            data[i] = 0; data[i + 1] = 0; data[i + 2] = avg * 4;
                        } else if (avg < 128) {
                            data[i] = 0; data[i + 1] = (avg - 64) * 4; data[i + 2] = 255;
                        } else if (avg < 192) {
                            data[i] = (avg - 128) * 4; data[i + 1] = 255; data[i + 2] = 255 - (avg - 128) * 4;
                        } else {
                            data[i] = 255; data[i + 1] = 255 - (avg - 192) * 4; data[i + 2] = 0;
                        }
                    }
                    break;

                case 'xray':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = 255 - avg;
                        data[i + 1] = 255 - avg + 20;
                        data[i + 2] = 255 - avg + 50;
                    }
                    break;

                case 'emboss':
                    const w = canvas.width;
                    const tempData = new Uint8ClampedArray(data);
                    for (let y = 1; y < canvas.height - 1; y++) {
                        for (let x = 1; x < canvas.width - 1; x++) {
                            const idx = (y * w + x) * 4;
                            for (let c = 0; c < 3; c++) {
                                const val = 128 +
                                    tempData[((y - 1) * w + (x - 1)) * 4 + c] * -2 +
                                    tempData[((y - 1) * w + x) * 4 + c] * -1 +
                                    tempData[(y * w + (x - 1)) * 4 + c] * -1 +
                                    tempData[(y * w + (x + 1)) * 4 + c] * 1 +
                                    tempData[((y + 1) * w + x) * 4 + c] * 1 +
                                    tempData[((y + 1) * w + (x + 1)) * 4 + c] * 2;
                                data[idx + c] = val;
                            }
                        }
                    }
                    break;

                case 'duotone':
                    for (let i = 0; i < data.length; i += 4) {
                        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        data[i] = avg < 128 ? avg * 2 : 255;
                        data[i + 1] = avg < 128 ? 0 : (avg - 128) * 2;
                        data[i + 2] = avg < 128 ? 255 - avg : 255;
                    }
                    break;

                case 'vhs':
                    // Scanlines + noise + color bleeding
                    for (let y = 0; y < canvas.height; y++) {
                        for (let x = 0; x < canvas.width; x++) {
                            const i = (y * canvas.width + x) * 4;
                            // Add noise
                            const noise = (Math.random() - 0.5) * 30;
                            // Scanlines
                            const scanline = y % 3 === 0 ? 0.8 : 1;
                            // Color bleed
                            const bleedX = Math.min(canvas.width - 1, x + 2);
                            const bleedIdx = (y * canvas.width + bleedX) * 4;

                            data[i] = Math.min(255, Math.max(0, (data[i] + data[bleedIdx] * 0.1 + noise) * scanline));
                            data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] + noise * 0.5) * scanline));
                            data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] + noise) * scanline));
                        }
                    }
                    break;

                case 'drunk':
                    const t = Date.now() * 0.003;
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.rotate(Math.sin(t) * 0.05);
                    ctx.scale(1 + Math.sin(t * 1.5) * 0.05, 1 + Math.cos(t * 1.3) * 0.05);
                    ctx.translate(-canvas.width / 2, -canvas.height / 2);
                    ctx.drawImage(video, Math.sin(t * 2) * 10, Math.cos(t * 2) * 10);
                    ctx.restore();
                    ctx.globalAlpha = 0.4;
                    ctx.drawImage(video, Math.sin(t) * 15, Math.cos(t) * 15);
                    ctx.globalAlpha = 1;
                    return;

                default:
                    return;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function takePhoto() {
            if (!stream) {
                alert('Please start the camera first!');
                return;
            }

            const dataUrl = canvas.toDataURL('image/png');

            const img = document.createElement('img');
            img.src = dataUrl;
            img.className = 'w-32 h-32 object-cover rounded-lg shadow-lg cursor-pointer hover:scale-105 transition-transform';
            img.onclick = () => {
                const link = document.createElement('a');
                link.download = `funny-photo-${Date.now()}.png`;
                link.href = dataUrl;
                link.click();
            };

            snapshots.prepend(img);
            gallery.classList.remove('hidden');
        }
    </script>
</body>

</html>