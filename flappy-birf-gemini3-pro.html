<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird Clone</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive, sans-serif;
            touch-action: manipulation;
            /* Prevent double-tap zoom */
        }

        canvas {
            image-rendering: pixelated;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        .animate-shake {
            animation: shake 0.2s ease-in-out;
        }
    </style>
</head>

<body class="bg-gray-800 h-screen w-screen flex items-center justify-center overflow-hidden select-none">

    <div class="relative group">
        <!-- Game Canvas -->
        <canvas id="gameCanvas" width="320" height="480"
            class="border-4 border-gray-900 bg-sky-300 shadow-2xl rounded-lg cursor-pointer"></canvas>

        <!-- UI Overlay -->
        <div id="uiLayer"
            class="absolute inset-0 pointer-events-none flex flex-col justify-center items-center text-center">

            <!-- Start Screen -->
            <div id="startScreen" class="flex flex-col items-center animate-pulse">
                <h1 class="text-4xl text-white drop-shadow-[0_4px_0_rgba(0,0,0,1)] mb-4"
                    style="-webkit-text-stroke: 2px black;">FLAPPY<br>BIRD</h1>
                <p class="text-white text-sm bg-black/50 px-4 py-2 rounded">Tap or Press Space to Start</p>
            </div>

            <!-- Game Over Screen (Hidden by default) -->
            <div id="gameOverScreen" class="hidden flex-col items-center">
                <h1 class="text-4xl text-orange-500 drop-shadow-[0_4px_0_rgba(0,0,0,1)] mb-2"
                    style="-webkit-text-stroke: 2px black;">GAME OVER</h1>

                <div class="bg-[#DED895] border-4 border-[#543847] p-4 rounded-lg shadow-lg mb-4 w-64">
                    <div class="flex flex-col gap-2">
                        <div class="flex justify-between items-end">
                            <span class="text-[#E9603B] text-xs">SCORE</span>
                            <span id="finalScore"
                                class="text-white text-xl drop-shadow-[0_2px_0_rgba(0,0,0,0.5)]">0</span>
                        </div>
                        <div class="flex justify-between items-end">
                            <span class="text-[#E9603B] text-xs">BEST</span>
                            <span id="bestScore"
                                class="text-white text-xl drop-shadow-[0_2px_0_rgba(0,0,0,0.5)]">0</span>
                        </div>
                    </div>
                </div>

                <button id="restartBtn"
                    class="pointer-events-auto bg-[#E9603B] border-2 border-white text-white px-4 py-2 rounded shadow-[0_4px_0_#9e4128] active:shadow-[0_0_0_#9e4128] active:translate-y-[4px] transition-all">
                    PLAY AGAIN
                </button>
            </div>
        </div>

        <!-- In-game Score -->
        <div id="scoreDisplay" class="absolute top-10 w-full text-center pointer-events-none hidden">
            <span id="currentScore" class="text-4xl text-white font-bold drop-shadow-[0_4px_0_rgba(0,0,0,0.5)]"
                style="-webkit-text-stroke: 2px black;">0</span>
        </div>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 320;
        const CANVAS_HEIGHT = 480;
        const GRAVITY = 0.25;
        const JUMP = -4.5;
        const PIPE_SPEED = 2;
        const PIPE_SPAWN_RATE = 100; // Frames
        const PIPE_GAP = 100;

        // Game Variables
        let canvas = document.getElementById('gameCanvas');
        let ctx = canvas.getContext('2d');
        let frames = 0;
        let score = 0;
        let highScore = localStorage.getItem('flappyHighScore') || 0;
        let gameState = 'START'; // START, PLAYING, GAMEOVER
        let lastDeathTime = 0;

        // DOM Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const currentScoreEl = document.getElementById('currentScore');
        const finalScoreEl = document.getElementById('finalScore');
        const bestScoreEl = document.getElementById('bestScore');
        const restartBtn = document.getElementById('restartBtn');

        // Assets
        // We will draw simple graphics instead of loading images to ensure it works instantly

        const bird = {
            x: 50,
            y: 150,
            w: 34,
            h: 24,
            radius: 12,
            velocity: 0,
            rotation: 0,

            draw: function () {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Rotation based on velocity
                if (this.velocity < 0) this.rotation = -25 * Math.PI / 180;
                else {
                    this.rotation += 2 * Math.PI / 180;
                    if (this.rotation > 90 * Math.PI / 180) this.rotation = 90 * Math.PI / 180;
                }
                ctx.rotate(this.rotation);

                // Body
                ctx.fillStyle = '#FFD700'; // Yellow
                ctx.beginPath();
                ctx.ellipse(0, 0, this.w / 2, this.h / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#000';
                ctx.stroke();

                // Eye
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(6, -6, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Pupil
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(8, -6, 2, 0, Math.PI * 2);
                ctx.fill();

                // Wing
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.ellipse(-6, 2, 8, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Beak
                ctx.fillStyle = '#FFA500'; // Orange
                ctx.beginPath();
                ctx.moveTo(8, 2);
                ctx.lineTo(16, 6);
                ctx.lineTo(8, 10);
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            },

            update: function () {
                this.velocity += GRAVITY;
                this.y += this.velocity;

                // Floor collision
                if (this.y + this.h / 2 >= CANVAS_HEIGHT - fg.h) {
                    this.y = CANVAS_HEIGHT - fg.h - this.h / 2;
                    gameOver();
                }

                // Ceiling collision
                if (this.y - this.h / 2 <= 0) {
                    this.y = this.h / 2;
                    this.velocity = 0;
                }
            },

            flap: function () {
                this.velocity = JUMP;
            },

            reset: function () {
                this.y = 150;
                this.velocity = 0;
                this.rotation = 0;
            }
        };

        const bg = {
            draw: function () {
                ctx.fillStyle = '#70c5ce';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw some clouds
                ctx.fillStyle = '#FFF';
                // Cloud 1
                ctx.beginPath(); ctx.arc(50, 300, 20, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(70, 310, 20, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(90, 290, 20, 0, Math.PI * 2); ctx.fill();

                // Cloud 2
                ctx.beginPath(); ctx.arc(250, 100, 30, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(280, 120, 30, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(220, 120, 30, 0, Math.PI * 2); ctx.fill();

                // Cityscape (simple)
                ctx.fillStyle = '#a3e899';
                ctx.fillRect(0, CANVAS_HEIGHT - fg.h - 50, CANVAS_WIDTH, 50);

                // Buildings
                ctx.fillStyle = '#85cf7a';
                ctx.fillRect(20, CANVAS_HEIGHT - fg.h - 80, 40, 80);
                ctx.fillRect(100, CANVAS_HEIGHT - fg.h - 60, 30, 60);
                ctx.fillRect(200, CANVAS_HEIGHT - fg.h - 100, 50, 100);
            }
        };

        const fg = {
            h: 100,
            x: 0,
            dx: 2,

            draw: function () {
                ctx.fillStyle = '#ded895';
                ctx.fillRect(0, CANVAS_HEIGHT - this.h, CANVAS_WIDTH, this.h);

                // Grass top
                ctx.fillStyle = '#73bf2e';
                ctx.fillRect(0, CANVAS_HEIGHT - this.h, CANVAS_WIDTH, 12);
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT - this.h + 12);
                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT - this.h + 12);
                ctx.stroke();

                // Striped pattern for ground movement effect
                ctx.strokeStyle = '#9ce659';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = this.x; i < CANVAS_WIDTH; i += 20) {
                    ctx.moveTo(i, CANVAS_HEIGHT - this.h + 2);
                    ctx.lineTo(i - 10, CANVAS_HEIGHT - this.h + 10);
                }
                ctx.stroke();

                // Border top
                ctx.fillStyle = '#553d00'; // Dark line
                ctx.fillRect(0, CANVAS_HEIGHT - this.h, CANVAS_WIDTH, 2);
            },

            update: function () {
                if (gameState === 'PLAYING') {
                    this.x = (this.x - this.dx) % 20;
                }
            }
        };

        const pipes = {
            position: [],

            w: 52,

            draw: function () {
                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    let topY = p.y;
                    let bottomY = p.y + PIPE_GAP;

                    // Pipe Body Color
                    ctx.fillStyle = '#73bf2e';
                    ctx.strokeStyle = '#553d00';
                    ctx.lineWidth = 2;

                    // Top Pipe
                    ctx.fillRect(p.x, 0, this.w, topY);
                    ctx.strokeRect(p.x, 0, this.w, topY);

                    // Top Pipe Cap
                    ctx.fillRect(p.x - 2, topY - 24, this.w + 4, 24);
                    ctx.strokeRect(p.x - 2, topY - 24, this.w + 4, 24);

                    // Bottom Pipe
                    ctx.fillRect(p.x, bottomY, this.w, CANVAS_HEIGHT - bottomY - fg.h);
                    ctx.strokeRect(p.x, bottomY, this.w, CANVAS_HEIGHT - bottomY - fg.h);

                    // Bottom Pipe Cap
                    ctx.fillRect(p.x - 2, bottomY, this.w + 4, 24);
                    ctx.strokeRect(p.x - 2, bottomY, this.w + 4, 24);

                    // Highlights
                    ctx.fillStyle = '#9ce659'; // Light green
                    ctx.fillRect(p.x + 4, 0, 4, topY - 24); // Top pipe highlight
                    ctx.fillRect(p.x + 4, bottomY + 24, 4, CANVAS_HEIGHT - bottomY - fg.h); // Bottom pipe highlight
                }
            },

            update: function () {
                if (frames % PIPE_SPAWN_RATE === 0) {
                    this.position.push({
                        x: CANVAS_WIDTH,
                        y: Math.random() * (CANVAS_HEIGHT - fg.h - PIPE_GAP - 100) + 50,
                        passed: false
                    });
                }

                for (let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= PIPE_SPEED;

                    // Collision Detection
                    let birdLeft = bird.x - bird.w / 2 + 5; // Hitbox adjustment
                    let birdRight = bird.x + bird.w / 2 - 5;
                    let birdTop = bird.y - bird.h / 2 + 5;
                    let birdBottom = bird.y + bird.h / 2 - 5;

                    let pipeLeft = p.x;
                    let pipeRight = p.x + this.w;
                    let topPipeBottom = p.y;
                    let bottomPipeTop = p.y + PIPE_GAP;

                    // Check collision with Top Pipe
                    if (birdRight > pipeLeft && birdLeft < pipeRight && birdTop < topPipeBottom) {
                        gameOver();
                    }
                    // Check collision with Bottom Pipe
                    if (birdRight > pipeLeft && birdLeft < pipeRight && birdBottom > bottomPipeTop) {
                        gameOver();
                    }

                    // Score Update
                    if (p.x + this.w < bird.x && !p.passed) {
                        score++;
                        scoreSound();
                        p.passed = true;
                        currentScoreEl.innerText = score;
                    }

                    // Remove off-screen pipes
                    if (p.x + this.w <= 0) {
                        this.position.shift();
                        i--; // Adjust index since array length changed
                    }
                }
            },

            reset: function () {
                this.position = [];
            }
        };

        // Input Handling
        function handleInput(e) {
            if (e.type === 'keydown') {
                if (e.code !== 'Space' && e.code !== 'ArrowUp') return;
            }
            // Prevent default behavior for spacebar to stop scrolling
            if (e.type === 'keydown') e.preventDefault();

            switch (gameState) {
                case 'START':
                    gameState = 'PLAYING';
                    startScreen.classList.add('hidden');
                    scoreDisplay.classList.remove('hidden');
                    bird.flap();
                    break;
                case 'PLAYING':
                    bird.flap();
                    break;
                case 'GAMEOVER':
                    // Click on restart button handled separately, but allow space to restart if gameover screen is fully shown
                    // Add delay to prevent accidental restart
                    if (!gameOverScreen.classList.contains('hidden') && Date.now() - lastDeathTime > 500) {
                        resetGame();
                    }
                    break;
            }
        }

        window.addEventListener('keydown', handleInput);
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // prevent zoom/scroll
            handleInput(e);
        }, { passive: false });

        restartBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // prevent triggering canvas click
            resetGame();
        });

        // Game Loop
        function loop() {
            // Update
            if (gameState === 'PLAYING') {
                bird.update();
                pipes.update();
                frames++;
            } else if (gameState === 'START') {
                // Bobbing animation for start screen
                bird.y = 150 + Math.sin(Date.now() / 300) * 5;
            }

            fg.update();

            // Draw
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            bg.draw();
            pipes.draw();
            fg.draw();
            bird.draw();

            // Draw Flash on collision
            if (gameState === 'GAMEOVER' && frames === 0) { // Just for a frame if we wanted flash
                // Flash implementation could go here
            }

            requestAnimationFrame(loop);
        }

        function gameOver() {
            if (gameState === 'GAMEOVER') return;
            gameState = 'GAMEOVER';
            lastDeathTime = Date.now();

            // Shake effect
            canvas.classList.add('animate-shake');
            setTimeout(() => canvas.classList.remove('animate-shake'), 200);

            // Update High Score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('flappyHighScore', highScore);
            }

            // Update UI
            finalScoreEl.innerText = score;
            bestScoreEl.innerText = highScore;
            scoreDisplay.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            gameOverScreen.classList.add('flex');
        }

        function resetGame() {
            bird.reset();
            pipes.reset();
            score = 0;
            frames = 0;
            currentScoreEl.innerText = score;
            gameState = 'START';

            gameOverScreen.classList.add('hidden');
            gameOverScreen.classList.remove('flex');
            startScreen.classList.remove('hidden');
        }

        function scoreSound() {
            // Very simple synthesized beep if possible, or just silent
            // For a single file with no external assets, we skip audio or use AudioContext
            // Simple AudioContext beep
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    const audioCtx = new AudioContext();
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();

                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);

                    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);

                    oscillator.start();
                    oscillator.stop(audioCtx.currentTime + 0.1);
                }
            } catch (e) {
                // Ignore audio errors
            }
        }

        // Start Loop
        loop();

    </script>
</body>

</html>