<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basketball Free Throw Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
        }

        .swish-text {
            animation: swishAnim 1s ease-out forwards;
        }

        @keyframes swishAnim {
            0% {
                transform: scale(0.5);
                opacity: 1;
            }

            50% {
                transform: scale(1.5);
                opacity: 1;
            }

            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        .streak-fire {
            animation: firePulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes firePulse {
            from {
                text-shadow: 0 0 10px #ff6b00, 0 0 20px #ff6b00;
            }

            to {
                text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            }
        }
    </style>
</head>

<body class="bg-gray-900">
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui" class="fixed top-4 left-0 right-0 flex justify-center gap-8 pointer-events-none">
        <div class="bg-black/50 backdrop-blur px-6 py-3 rounded-xl text-center">
            <div class="text-orange-400 text-sm font-semibold">SCORE</div>
            <div id="score" class="text-white text-3xl font-bold">0</div>
        </div>
        <div class="bg-black/50 backdrop-blur px-6 py-3 rounded-xl text-center">
            <div class="text-orange-400 text-sm font-semibold">STREAK</div>
            <div id="streak" class="text-white text-3xl font-bold">0</div>
        </div>
        <div class="bg-black/50 backdrop-blur px-6 py-3 rounded-xl text-center">
            <div class="text-orange-400 text-sm font-semibold">BEST</div>
            <div id="best" class="text-white text-3xl font-bold">0</div>
        </div>
    </div>

    <!-- Swish Notification -->
    <div id="swishNotif" class="fixed inset-0 flex items-center justify-center pointer-events-none opacity-0">
        <div class="text-6xl font-black text-yellow-400 swish-text">SWISH! üí´</div>
    </div>

    <!-- Instructions -->
    <div id="instructions" class="fixed bottom-8 left-0 right-0 text-center pointer-events-none">
        <div class="text-white/70 text-lg">Swipe up to shoot! üèÄ</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Responsive canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        let score = 0;
        let streak = 0;
        let bestStreak = 0;
        let isSwishing = false;
        let hitRim = false;

        // Ball properties
        const ball = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            radius: 25,
            rotation: 0,
            rotationSpeed: 0,
            active: false,
            scored: false
        };

        // Hoop properties
        const hoop = {
            x: 0,
            y: 0,
            rimRadius: 45,
            rimThickness: 8,
            backboardWidth: 15,
            backboardHeight: 120,
            netPoints: []
        };

        // Swipe tracking
        let swipeStart = null;
        let swipeEnd = null;
        let isDragging = false;
        let swipeTrail = [];

        // Starting position
        function getStartPos() {
            return {
                x: canvas.width / 2,
                y: canvas.height - 150
            };
        }

        // Initialize positions
        function initPositions() {
            const start = getStartPos();
            ball.x = start.x;
            ball.y = start.y;

            hoop.x = canvas.width / 2;
            hoop.y = canvas.height * 0.28;

            // Initialize net points
            initNet();
        }

        function initNet() {
            hoop.netPoints = [];
            const segments = 8;
            const netDepth = 50;
            for (let i = 0; i <= segments; i++) {
                const angle = Math.PI + (Math.PI * i / segments);
                hoop.netPoints.push({
                    x: hoop.x + Math.cos(angle) * hoop.rimRadius * 0.9,
                    y: hoop.y + netDepth,
                    baseX: hoop.x + Math.cos(angle) * hoop.rimRadius * 0.9,
                    baseY: hoop.y + netDepth,
                    vy: 0
                });
            }
        }

        initPositions();
        window.addEventListener('resize', initPositions);

        // Physics constants
        const gravity = 0.4;
        const airResistance = 0.995;
        const bounceEnergy = 0.6;

        // Input handlers
        function getEventPos(e) {
            if (e.touches) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function handleStart(e) {
            e.preventDefault();
            if (ball.active) return;

            const pos = getEventPos(e);
            const start = getStartPos();
            const dist = Math.hypot(pos.x - start.x, pos.y - start.y);

            if (dist < 100) {
                isDragging = true;
                swipeStart = pos;
                swipeTrail = [pos];
            }
        }

        function handleMove(e) {
            e.preventDefault();
            if (!isDragging) return;

            const pos = getEventPos(e);
            swipeEnd = pos;
            swipeTrail.push(pos);
            if (swipeTrail.length > 15) swipeTrail.shift();
        }

        function handleEnd(e) {
            e.preventDefault();
            if (!isDragging || !swipeStart || !swipeEnd) {
                isDragging = false;
                return;
            }

            const dx = swipeEnd.x - swipeStart.x;
            const dy = swipeEnd.y - swipeStart.y;

            // Only shoot if swiping upward
            if (dy < -30) {
                const power = Math.min(Math.hypot(dx, dy) * 0.12, 25);
                const angle = Math.atan2(dy, dx);

                ball.vx = Math.cos(angle) * power;
                ball.vy = Math.sin(angle) * power;
                ball.rotationSpeed = ball.vx * 0.05;
                ball.active = true;
                ball.scored = false;
                hitRim = false;

                document.getElementById('instructions').style.opacity = '0';
            }

            isDragging = false;
            swipeStart = null;
            swipeEnd = null;
            swipeTrail = [];
        }

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseleave', handleEnd);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);

        // Collision detection with rim
        function checkRimCollision() {
            const leftRimX = hoop.x - hoop.rimRadius;
            const rightRimX = hoop.x + hoop.rimRadius;
            const rimY = hoop.y;

            // Left rim collision
            let dist = Math.hypot(ball.x - leftRimX, ball.y - rimY);
            if (dist < ball.radius + hoop.rimThickness / 2) {
                hitRim = true;
                const angle = Math.atan2(ball.y - rimY, ball.x - leftRimX);
                const overlap = ball.radius + hoop.rimThickness / 2 - dist;
                ball.x += Math.cos(angle) * overlap;
                ball.y += Math.sin(angle) * overlap;

                const normalX = Math.cos(angle);
                const normalY = Math.sin(angle);
                const dot = ball.vx * normalX + ball.vy * normalY;
                ball.vx = (ball.vx - 2 * dot * normalX) * bounceEnergy;
                ball.vy = (ball.vy - 2 * dot * normalY) * bounceEnergy;
                ball.rotationSpeed = -ball.rotationSpeed * 0.5;
            }

            // Right rim collision
            dist = Math.hypot(ball.x - rightRimX, ball.y - rimY);
            if (dist < ball.radius + hoop.rimThickness / 2) {
                hitRim = true;
                const angle = Math.atan2(ball.y - rimY, ball.x - rightRimX);
                const overlap = ball.radius + hoop.rimThickness / 2 - dist;
                ball.x += Math.cos(angle) * overlap;
                ball.y += Math.sin(angle) * overlap;

                const normalX = Math.cos(angle);
                const normalY = Math.sin(angle);
                const dot = ball.vx * normalX + ball.vy * normalY;
                ball.vx = (ball.vx - 2 * dot * normalX) * bounceEnergy;
                ball.vy = (ball.vy - 2 * dot * normalY) * bounceEnergy;
                ball.rotationSpeed = -ball.rotationSpeed * 0.5;
            }

            // Backboard collision
            const backboardX = hoop.x + hoop.rimRadius + 20;
            const backboardTop = hoop.y - hoop.backboardHeight / 2;
            const backboardBottom = hoop.y + hoop.backboardHeight / 2;

            if (ball.x + ball.radius > backboardX &&
                ball.x - ball.radius < backboardX + hoop.backboardWidth &&
                ball.y > backboardTop && ball.y < backboardBottom) {
                ball.x = backboardX - ball.radius;
                ball.vx = -ball.vx * bounceEnergy;
                hitRim = true;
            }
        }

        // Check if ball goes through hoop
        function checkScore() {
            if (ball.scored) return;

            const inHoopX = Math.abs(ball.x - hoop.x) < hoop.rimRadius - ball.radius * 0.5;
            const crossedRim = ball.y > hoop.y && ball.y < hoop.y + 30 && ball.vy > 0;

            if (inHoopX && crossedRim) {
                ball.scored = true;

                // Animate net
                hoop.netPoints.forEach(p => {
                    p.vy = 8;
                });

                // Check for swish
                if (!hitRim) {
                    score += 3;
                    showSwish();
                } else {
                    score += 2;
                }

                streak++;
                if (streak > bestStreak) bestStreak = streak;

                updateUI();
            }
        }

        function showSwish() {
            const notif = document.getElementById('swishNotif');
            notif.style.opacity = '1';
            setTimeout(() => {
                notif.style.opacity = '0';
            }, 1000);
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            const streakEl = document.getElementById('streak');
            streakEl.textContent = streak;
            if (streak >= 3) {
                streakEl.classList.add('streak-fire');
                streakEl.style.color = '#ff6b00';
            } else {
                streakEl.classList.remove('streak-fire');
                streakEl.style.color = 'white';
            }
            document.getElementById('best').textContent = bestStreak;
        }

        // Reset ball
        function resetBall() {
            const start = getStartPos();
            ball.x = start.x;
            ball.y = start.y;
            ball.vx = 0;
            ball.vy = 0;
            ball.rotation = 0;
            ball.rotationSpeed = 0;
            ball.active = false;

            if (!ball.scored) {
                streak = 0;
                updateUI();
            }

            document.getElementById('instructions').style.opacity = '1';
        }

        // Update physics
        function update() {
            if (ball.active) {
                // Apply gravity
                ball.vy += gravity;

                // Apply air resistance
                ball.vx *= airResistance;
                ball.vy *= airResistance;

                // Update position
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Rotation
                ball.rotation += ball.rotationSpeed;

                // Collision detection
                checkRimCollision();

                // Score detection
                checkScore();

                // Reset if out of bounds
                if (ball.y > canvas.height + 100 || ball.x < -100 || ball.x > canvas.width + 100) {
                    setTimeout(resetBall, 500);
                    ball.active = false;
                }
            }

            // Update net physics
            hoop.netPoints.forEach(p => {
                p.vy += 0.3;
                p.y += p.vy;
                if (p.y > p.baseY) {
                    p.y = p.baseY;
                    p.vy = -p.vy * 0.5;
                }
                if (p.y < p.baseY - 20) {
                    p.vy += 1;
                }
            });
        }

        // Drawing functions
        function drawCourt() {
            // Court gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Court floor
            ctx.fillStyle = '#c4956a';
            ctx.fillRect(0, canvas.height - 80, canvas.width, 80);

            // Court lines
            ctx.strokeStyle = '#ffffff40';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 80);
            ctx.lineTo(canvas.width, canvas.height - 80);
            ctx.stroke();

            // Free throw line
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height - 80, 150, Math.PI, 0);
            ctx.stroke();
        }

        function drawHoop() {
            // Backboard
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(
                hoop.x + hoop.rimRadius + 20,
                hoop.y - hoop.backboardHeight / 2,
                hoop.backboardWidth,
                hoop.backboardHeight
            );
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.strokeRect(
                hoop.x + hoop.rimRadius + 20,
                hoop.y - hoop.backboardHeight / 2,
                hoop.backboardWidth,
                hoop.backboardHeight
            );

            // Backboard square
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                hoop.x + hoop.rimRadius + 22,
                hoop.y - 30,
                10,
                60
            );

            // Rim
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = hoop.rimThickness;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(hoop.x - hoop.rimRadius, hoop.y);
            ctx.lineTo(hoop.x + hoop.rimRadius, hoop.y);
            ctx.stroke();

            // Rim connector
            ctx.beginPath();
            ctx.moveTo(hoop.x + hoop.rimRadius, hoop.y);
            ctx.lineTo(hoop.x + hoop.rimRadius + 20, hoop.y);
            ctx.stroke();

            // Net
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            // Vertical net strings
            for (let i = 0; i < hoop.netPoints.length; i++) {
                const topAngle = Math.PI + (Math.PI * i / (hoop.netPoints.length - 1));
                const topX = hoop.x + Math.cos(topAngle) * hoop.rimRadius;

                ctx.beginPath();
                ctx.moveTo(topX, hoop.y);
                ctx.quadraticCurveTo(
                    (topX + hoop.netPoints[i].x) / 2,
                    (hoop.y + hoop.netPoints[i].y) / 2 + 10,
                    hoop.netPoints[i].x,
                    hoop.netPoints[i].y
                );
                ctx.stroke();
            }

            // Horizontal net strings
            for (let row = 0; row < 4; row++) {
                const t = (row + 1) / 5;
                ctx.beginPath();
                for (let i = 0; i < hoop.netPoints.length; i++) {
                    const topAngle = Math.PI + (Math.PI * i / (hoop.netPoints.length - 1));
                    const topX = hoop.x + Math.cos(topAngle) * hoop.rimRadius;
                    const x = topX + (hoop.netPoints[i].x - topX) * t;
                    const y = hoop.y + (hoop.netPoints[i].y - hoop.y) * t;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        function drawBall(x, y, radius, rotation) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Ball shadow
            ctx.beginPath();
            ctx.ellipse(5, 5, radius, radius * 0.3, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();

            // Ball gradient
            const gradient = ctx.createRadialGradient(-radius * 0.3, -radius * 0.3, 0, 0, 0, radius);
            gradient.addColorStop(0, '#ff8c42');
            gradient.addColorStop(0.5, '#e65c00');
            gradient.addColorStop(1, '#cc4400');

            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Ball lines
            ctx.strokeStyle = '#00000040';
            ctx.lineWidth = 2;

            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(-radius, 0);
            ctx.lineTo(radius, 0);
            ctx.stroke();

            // Vertical line
            ctx.beginPath();
            ctx.moveTo(0, -radius);
            ctx.lineTo(0, radius);
            ctx.stroke();

            // Curved lines
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.7, -Math.PI * 0.4, Math.PI * 0.4);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.7, Math.PI * 0.6, Math.PI * 1.4);
            ctx.stroke();

            ctx.restore();
        }

        function drawSwipeTrail() {
            if (swipeTrail.length < 2) return;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 1; i < swipeTrail.length; i++) {
                const alpha = i / swipeTrail.length;
                ctx.strokeStyle = `rgba(255, 140, 66, ${alpha})`;
                ctx.lineWidth = 4 + alpha * 6;
                ctx.beginPath();
                ctx.moveTo(swipeTrail[i - 1].x, swipeTrail[i - 1].y);
                ctx.lineTo(swipeTrail[i].x, swipeTrail[i].y);
                ctx.stroke();
            }
        }

        function drawTrajectoryPreview() {
            if (!isDragging || !swipeStart || !swipeEnd) return;

            const dx = swipeEnd.x - swipeStart.x;
            const dy = swipeEnd.y - swipeStart.y;

            if (dy >= -30) return;

            const power = Math.min(Math.hypot(dx, dy) * 0.12, 25);
            const angle = Math.atan2(dy, dx);

            let px = ball.x;
            let py = ball.y;
            let pvx = Math.cos(angle) * power;
            let pvy = Math.sin(angle) * power;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.setLineDash([10, 10]);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px, py);

            for (let i = 0; i < 50; i++) {
                pvy += gravity;
                px += pvx;
                py += pvy;

                if (i % 3 === 0) {
                    ctx.lineTo(px, py);
                }

                if (py > canvas.height) break;
            }

            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawPowerIndicator() {
            if (!isDragging || !swipeStart || !swipeEnd) return;

            const dx = swipeEnd.x - swipeStart.x;
            const dy = swipeEnd.y - swipeStart.y;
            const power = Math.min(Math.hypot(dx, dy) / 200, 1);

            // Power bar background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(20, canvas.height / 2 - 100, 30, 200);

            // Power bar fill
            const gradient = ctx.createLinearGradient(0, canvas.height / 2 + 100, 0, canvas.height / 2 - 100);
            gradient.addColorStop(0, '#00ff00');
            gradient.addColorStop(0.5, '#ffff00');
            gradient.addColorStop(1, '#ff0000');
            ctx.fillStyle = gradient;
            ctx.fillRect(22, canvas.height / 2 + 98 - power * 196, 26, power * 196);

            // Power bar border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, canvas.height / 2 - 100, 30, 200);
        }

        // Main game loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawCourt();

            // Draw ball behind hoop if it's above the rim
            if (ball.y < hoop.y) {
                drawBall(ball.x, ball.y, ball.radius, ball.rotation);
            }

            drawHoop();

            // Draw ball in front of hoop if it's below the rim
            if (ball.y >= hoop.y) {
                drawBall(ball.x, ball.y, ball.radius, ball.rotation);
            }

            drawSwipeTrail();
            drawTrajectoryPreview();
            drawPowerIndicator();

            update();

            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>

</html>