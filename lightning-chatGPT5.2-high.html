<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lightning Generator • Branching Bolts</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #050814;
        }

        canvas {
            display: block;
        }

        .glass {
            background: rgba(8, 12, 24, 0.62);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 80px rgba(0, 0, 0, .55);
            backdrop-filter: blur(10px);
        }

        .mono {
            font-variant-numeric: tabular-nums;
        }
    </style>
</head>

<body class="text-slate-100">
    <canvas id="c" class="fixed inset-0"></canvas>

    <!-- UI -->
    <div class="fixed top-3 left-3 right-3 md:right-auto md:w-[420px] glass rounded-2xl p-4">
        <div class="flex items-center justify-between gap-3">
            <div>
                <h1 class="text-base font-semibold tracking-tight">Lightning Generator</h1>
                <p class="text-xs text-slate-300">Branching bolts • flash illumination • cloud sky</p>
            </div>
            <button id="strikeBtn"
                class="px-3 py-2 rounded-xl bg-sky-500/90 hover:bg-sky-400 active:bg-sky-300 text-slate-950 font-semibold shadow">
                Strike Now
            </button>
        </div>

        <div class="mt-4 grid grid-cols-1 gap-3">
            <div class="grid grid-cols-3 gap-3">
                <label class="col-span-1 text-xs text-slate-300">Strike rate</label>
                <input id="rate" class="col-span-2" type="range" min="0" max="100" value="55" />
            </div>
            <div class="grid grid-cols-3 gap-3">
                <label class="col-span-1 text-xs text-slate-300">Branching</label>
                <input id="branch" class="col-span-2" type="range" min="0" max="100" value="65" />
            </div>
            <div class="grid grid-cols-3 gap-3">
                <label class="col-span-1 text-xs text-slate-300">Intensity</label>
                <input id="intensity" class="col-span-2" type="range" min="0" max="100" value="75" />
            </div>
            <div class="grid grid-cols-3 gap-3">
                <label class="col-span-1 text-xs text-slate-300">Jitter</label>
                <input id="jitter" class="col-span-2" type="range" min="0" max="100" value="55" />
            </div>
        </div>

        <div class="mt-4 flex items-center justify-between text-xs text-slate-300">
            <div class="mono" id="status">arming…</div>
            <div class="hidden md:block">Click anywhere to aim the strike.</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        const ui = {
            rate: document.getElementById('rate'),
            branch: document.getElementById('branch'),
            intensity: document.getElementById('intensity'),
            jitter: document.getElementById('jitter'),
            strikeBtn: document.getElementById('strikeBtn'),
            status: document.getElementById('status'),
        };

        const DPR = () => Math.max(1, Math.min(2, window.devicePixelRatio || 1));

        function resize() {
            const dpr = DPR();
            canvas.width = Math.floor(innerWidth * dpr);
            canvas.height = Math.floor(innerHeight * dpr);
            canvas.style.width = innerWidth + 'px';
            canvas.style.height = innerHeight + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            cloudsA = makeCloudLayer(innerWidth, innerHeight, 1);
            cloudsB = makeCloudLayer(innerWidth, innerHeight, 2);
        }
        window.addEventListener('resize', resize);

        // --- Random helpers ---
        const rand = (a = 1, b = 0) => Math.random() * (a - b) + b;
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const lerp = (a, b, t) => a + (b - a) * t;
        const smoothstep = (a, b, t) => {
            t = clamp((t - a) / (b - a), 0, 1);
            return t * t * (3 - 2 * t);
        };

        // --- Cloud backdrop ---
        let cloudsA, cloudsB;

        function makeCloudLayer(w, h, seedBias = 1) {
            const off = document.createElement('canvas');
            off.width = w;
            off.height = h;
            const g = off.getContext('2d');

            // Base sky gradient
            const sky = g.createLinearGradient(0, 0, 0, h);
            sky.addColorStop(0, '#050816');
            sky.addColorStop(0.45, '#07122b');
            sky.addColorStop(1, '#050814');
            g.fillStyle = sky;
            g.fillRect(0, 0, w, h);

            // Cloud mass: blurred puffs
            g.save();
            g.globalCompositeOperation = 'screen';
            g.filter = 'blur(28px)';

            // A faint fog band near top (storm ceiling)
            const bandY = h * (0.10 + 0.02 * seedBias);
            for (let i = 0; i < 18; i++) {
                const y = bandY + rand(h * 0.05, -h * 0.03);
                const x = rand(w, 0);
                const r = rand(w * 0.28, w * 0.12);
                const a = rand(0.10, 0.05) * (seedBias === 2 ? 0.85 : 1.0);
                g.fillStyle = `rgba(120,155,210,${a})`;
                g.beginPath();
                g.arc(x, y, r, 0, Math.PI * 2);
                g.fill();
            }

            // Bigger cloud puffs
            const puffCount = Math.floor(170 + seedBias * 40);
            for (let i = 0; i < puffCount; i++) {
                const t = i / (puffCount - 1);
                const y = lerp(h * 0.05, h * 0.70, Math.pow(t, 1.6)) + rand(h * 0.05, -h * 0.05);
                const x = rand(w, 0);
                const r = rand(w * 0.20, w * 0.04) * (0.55 + (1 - t) * 0.8);
                const a = rand(0.13, 0.03) * (0.7 + (1 - t) * 0.6);
                const c = (seedBias === 2) ? 'rgba(70,110,190,' : 'rgba(95,135,210,';
                g.fillStyle = c + a + ')';
                g.beginPath();
                g.arc(x, y, r, 0, Math.PI * 2);
                g.fill();
            }

            g.restore();

            // Vignette
            const vig = g.createRadialGradient(w * 0.5, h * 0.55, Math.min(w, h) * 0.1, w * 0.5, h * 0.55, Math.max(w, h) * 0.65);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,0.72)');
            g.fillStyle = vig;
            g.fillRect(0, 0, w, h);

            return off;
        }

        // --- Lightning bolt generation ---
        // Midpoint displacement trunk with recursive branching.
        function subdivide(points, jitter, depth, maxDepth, roughness) {
            if (depth >= maxDepth) return points;
            const out = [points[0]];
            for (let i = 0; i < points.length - 1; i++) {
                const a = points[i];
                const b = points[i + 1];
                const mid = {
                    x: (a.x + b.x) * 0.5,
                    y: (a.y + b.y) * 0.5,
                };
                // perpendicular displacement
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const len = Math.hypot(dx, dy) || 1;
                const nx = -dy / len;
                const ny = dx / len;

                const fade = 1 - (depth / (maxDepth + 1));
                const disp = (rand(1, -1)) * jitter * Math.pow(roughness, depth) * fade;
                mid.x += nx * disp;
                mid.y += ny * disp;

                out.push(mid, b);
            }
            return subdivide(out, jitter, depth + 1, maxDepth, roughness);
        }

        function generateBolt(start, end, opts) {
            const {
                jitter = 90,
                depth = 7,
                roughness = 0.72,
                branchProb = 0.22,
                branchAngle = Math.PI / 3.2,
                branchScale = 0.55,
                maxBranches = 16,
            } = opts || {};

            // Main trunk points
            let trunk = subdivide([start, end], jitter, 0, depth, roughness);

            // Slight smoothing (keeps jagged but reduces artifacts)
            trunk = trunk.map((p, i) => {
                if (i === 0 || i === trunk.length - 1) return p;
                const a = trunk[i - 1], b = trunk[i], c = trunk[i + 1];
                return { x: (a.x + b.x + c.x) / 3, y: (a.y + b.y + c.y) / 3 };
            });

            const paths = [{ points: trunk, kind: 'trunk', life: 1 }];

            let branchCount = 0;
            for (let i = 6; i < trunk.length - 10; i++) {
                const t = i / (trunk.length - 1);
                const p = trunk[i];
                const p2 = trunk[i + 1];
                const segdx = p2.x - p.x;
                const segdy = p2.y - p.y;
                const segLen = Math.hypot(segdx, segdy) || 1;
                const ang = Math.atan2(segdy, segdx);

                const prob = branchProb * (1 - smoothstep(0.45, 1, t));
                if (Math.random() < prob && branchCount < maxBranches) {
                    branchCount++;
                    const side = Math.random() < 0.5 ? -1 : 1;
                    const a = ang + side * (branchAngle * rand(1.05, 0.65));
                    const len = segLen * rand(220, 80) * branchScale * (1 - t * 0.35);
                    const endB = {
                        x: p.x + Math.cos(a) * len,
                        y: p.y + Math.sin(a) * len + len * rand(0.25, 0.05),
                    };
                    let branch = subdivide([p, endB], jitter * 0.55, 0, Math.max(4, depth - 2), roughness * 0.92);
                    paths.push({ points: branch, kind: 'branch', life: rand(0.85, 0.55) });

                    // Occasional sub-branch
                    if (Math.random() < 0.35 && branchCount < maxBranches) {
                        branchCount++;
                        const pick = branch[Math.floor(branch.length * rand(0.65, 0.25))];
                        const a2 = a + side * rand(0.8, -0.8);
                        const len2 = len * rand(0.55, 0.25);
                        const endC = { x: pick.x + Math.cos(a2) * len2, y: pick.y + Math.sin(a2) * len2 + len2 * 0.2 };
                        const b2 = subdivide([pick, endC], jitter * 0.42, 0, Math.max(3, depth - 3), roughness * 0.95);
                        paths.push({ points: b2, kind: 'branch', life: rand(0.65, 0.4) });
                    }
                }
            }

            // A focal point for lighting (approx centroid of lower trunk)
            const focusIndex = Math.floor(trunk.length * 0.72);
            const focus = trunk[focusIndex] || end;

            return { paths, focus, start, end };
        }

        function strokePath(points, width, color, alpha = 1) {
            if (!points || points.length < 2) return;
            ctx.globalAlpha = alpha;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        // --- Strike scheduler (timing variation + flicker pulses) ---
        let targetX = null;
        let bolts = [];
        let flash = 0;
        let skyKick = 0;
        let shake = { x: 0, y: 0, vx: 0, vy: 0 };

        const nowMs = () => performance.now();

        function rateToIntervalMs() {
            // 0..100 -> ~[2400..280] ms with a long tail
            const r = Number(ui.rate.value) / 100;
            const base = lerp(2400, 280, Math.pow(r, 0.85));
            // Add random variation (stormy irregularity)
            const variation = rand(base * 0.9, base * 0.1);
            return base + variation;
        }

        let nextStrikeAt = 0;

        function armNextStrike(t) {
            nextStrikeAt = t + rateToIntervalMs();
        }

        function strike(atX = null) {
            const intensity = Number(ui.intensity.value) / 100;
            const branching = Number(ui.branch.value) / 100;
            const jitter = Number(ui.jitter.value) / 100;

            const w = innerWidth, h = innerHeight;
            const cloudY = lerp(h * 0.08, h * 0.20, 0.6);

            const sx = (atX ?? (targetX ?? rand(w * 0.85, w * 0.15))) + rand(120, -120);
            const ex = (atX ?? (targetX ?? rand(w * 0.85, w * 0.15))) + rand(180, -180);

            const start = { x: clamp(sx, 20, w - 20), y: cloudY + rand(28, -18) };
            const end = { x: clamp(ex, 20, w - 20), y: h - lerp(28, 64, Math.random()) };

            const bolt = generateBolt(start, end, {
                jitter: lerp(40, 140, jitter),
                depth: Math.floor(lerp(5, 8, jitter)),
                roughness: lerp(0.78, 0.66, jitter),
                branchProb: lerp(0.02, 0.32, branching),
                branchAngle: lerp(Math.PI / 5.5, Math.PI / 2.6, branching),
                branchScale: lerp(0.42, 0.72, branching),
                maxBranches: Math.floor(lerp(5, 22, branching)),
            });

            // Flicker pulses: a single strike is multiple short flashes
            const t0 = nowMs();
            const pulses = [];
            const pulseCount = 2 + Math.floor(rand(4, 0) * intensity);
            let accum = 0;
            for (let i = 0; i < pulseCount; i++) {
                const gap = rand(85, 22) * (i === 0 ? 0.2 : 1);
                accum += gap;
                pulses.push({
                    at: t0 + accum,
                    dur: rand(85, 32),
                    amp: (i === 0 ? 1 : rand(0.95, 0.35)) * (0.55 + intensity * 0.7),
                });
            }

            bolts.push({
                bolt,
                born: t0,
                ttl: 520,
                pulses,
                seed: Math.random(),
            });

            // Immediate lighting kick
            flash = Math.max(flash, 0.55 + intensity * 0.55);
            skyKick = Math.max(skyKick, 0.35 + intensity * 0.6);

            // Camera shake impulse
            shake.vx += rand(10, -10) * (0.4 + intensity);
            shake.vy += rand(6, -6) * (0.35 + intensity);

            // Schedule next strike
            armNextStrike(t0);
        }

        ui.strikeBtn.addEventListener('click', () => strike(targetX ?? innerWidth * 0.5));
        window.addEventListener('pointerdown', (e) => {
            targetX = e.clientX;
            strike(targetX);
        });

        // --- Render loop ---
        let last = performance.now();

        function drawBackground(t) {
            const w = innerWidth, h = innerHeight;

            // Base sky (dynamic with flash)
            const fl = clamp(flash, 0, 1);
            const kick = clamp(skyKick, 0, 1);

            const sky = ctx.createLinearGradient(0, 0, 0, h);
            // more cyan/blue during flashes
            const top = `rgb(${Math.floor(lerp(5, 40, kick))}, ${Math.floor(lerp(8, 90, kick))}, ${Math.floor(lerp(22, 140, kick))})`;
            const mid = `rgb(${Math.floor(lerp(7, 30, kick))}, ${Math.floor(lerp(18, 70, kick))}, ${Math.floor(lerp(43, 125, kick))})`;
            sky.addColorStop(0, top);
            sky.addColorStop(0.55, mid);
            sky.addColorStop(1, '#050814');
            ctx.fillStyle = sky;
            ctx.fillRect(0, 0, w, h);

            // Cloud parallax
            const wind = 0.004;
            const oxA = (t * wind * 18) % w;
            const oxB = (t * wind * 28) % w;

            ctx.globalAlpha = 0.95;
            ctx.drawImage(cloudsA, -oxA, 0);
            ctx.drawImage(cloudsA, -oxA + w, 0);

            ctx.globalAlpha = 0.75;
            ctx.drawImage(cloudsB, oxB - w, 0);
            ctx.drawImage(cloudsB, oxB, 0);

            ctx.globalAlpha = 1;

            // Distant haze near horizon
            const haze = ctx.createLinearGradient(0, h * 0.55, 0, h);
            haze.addColorStop(0, 'rgba(10,18,40,0)');
            haze.addColorStop(1, 'rgba(5,8,20,0.9)');
            ctx.fillStyle = haze;
            ctx.fillRect(0, 0, w, h);

            // Flash overlay (broad)
            if (fl > 0.001) {
                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = `rgba(210,235,255,${fl * 0.32})`;
                ctx.fillRect(0, 0, w, h);
                ctx.restore();
            }
        }

        function pulseValue(strike, t) {
            let v = 0;
            for (const p of strike.pulses) {
                const dt = t - p.at;
                if (dt >= 0 && dt <= p.dur) {
                    const x = dt / p.dur;
                    // sharp rise, longer decay
                    const env = (x < 0.15) ? (x / 0.15) : Math.pow(1 - (x - 0.15) / 0.85, 1.6);
                    v = Math.max(v, env * p.amp);
                }
            }
            return v;
        }

        function drawBolts(t) {
            if (!bolts.length) return;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const intensity = Number(ui.intensity.value) / 100;

            for (const s of bolts) {
                const age = t - s.born;
                const alive = age <= s.ttl;
                if (!alive) continue;

                const pulse = pulseValue(s, t);
                if (pulse <= 0.001) continue;

                // Lighting around strike focus
                ctx.save();
                const f = s.bolt.focus;
                const w = innerWidth, h = innerHeight;
                const r = Math.min(w, h) * lerp(0.26, 0.42, intensity) * (0.7 + pulse * 0.6);
                const rg = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, r);
                rg.addColorStop(0, `rgba(200,235,255,${0.32 * pulse})`);
                rg.addColorStop(0.45, `rgba(80,150,255,${0.12 * pulse})`);
                rg.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = rg;
                ctx.globalCompositeOperation = 'screen';
                ctx.fillRect(0, 0, w, h);
                ctx.restore();

                // Draw bolt paths: glow + core
                for (const p of s.bolt.paths) {
                    const kindMul = (p.kind === 'trunk') ? 1 : 0.7;
                    const a = pulse * p.life * kindMul;

                    // Outer glow
                    strokePath(p.points, 10, 'rgba(90,160,255,1)', 0.09 * a);
                    strokePath(p.points, 6, 'rgba(170,220,255,1)', 0.18 * a);
                    // Inner core
                    strokePath(p.points, 2.6, 'rgba(255,255,255,1)', 0.95 * a);
                }
            }

            ctx.restore();
        }

        function updatePhysics(dt) {
            // Flash + sky lighting decay
            flash = Math.max(0, flash - dt * 1.65);
            skyKick = Math.max(0, skyKick - dt * 0.95);

            // Camera shake (springy)
            shake.vx *= Math.pow(0.001, dt);
            shake.vy *= Math.pow(0.001, dt);
            shake.x += shake.vx * dt;
            shake.y += shake.vy * dt;
            shake.x *= Math.pow(0.0008, dt);
            shake.y *= Math.pow(0.0008, dt);
        }

        function pruneBolts(t) {
            bolts = bolts.filter(s => (t - s.born) <= (s.ttl + 120));
        }

        function loop(t) {
            const dt = Math.min(0.05, (t - last) / 1000);
            last = t;

            // Automatic strikes
            if (t >= nextStrikeAt) {
                strike(targetX ?? null);
            }

            updatePhysics(dt);

            // Apply shake transform
            ctx.save();
            ctx.translate(shake.x, shake.y);

            drawBackground(t);
            drawBolts(t);

            ctx.restore();

            pruneBolts(t);

            // Status
            const secs = Math.max(0, (nextStrikeAt - t) / 1000);
            ui.status.textContent = `next strike in ${secs.toFixed(2)}s • active ${bolts.length}`;

            requestAnimationFrame(loop);
        }

        // Init
        resize();
        armNextStrike(performance.now() + 200);
        requestAnimationFrame(loop);
    </script>
</body>

</html>