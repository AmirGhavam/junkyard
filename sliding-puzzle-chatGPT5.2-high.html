<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>15-Puzzle</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        :root {
            color-scheme: dark;
        }

        .board {
            position: relative;
            width: min(92vw, 460px);
            aspect-ratio: 1 / 1;
            border-radius: 1rem;
            overflow: hidden;
            background:
                radial-gradient(1200px 700px at 20% 10%, rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.02) 55%, rgba(0, 0, 0, 0) 70%),
                linear-gradient(145deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
            box-shadow:
                0 25px 60px rgba(0, 0, 0, 0.45),
                inset 0 1px 0 rgba(255, 255, 255, 0.12);
        }

        .grid-lines {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background:
                linear-gradient(to right, rgba(255, 255, 255, 0.06) 1px, transparent 1px) 0 0 / 25% 100%,
                linear-gradient(to bottom, rgba(255, 255, 255, 0.06) 1px, transparent 1px) 0 0 / 100% 25%;
            opacity: 0.65;
            mix-blend-mode: overlay;
        }

        .tile {
            position: absolute;
            width: 25%;
            height: 25%;
            transform: translate(0%, 0%);
            transition: transform 180ms cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 180ms ease;
            border-radius: 0.9rem;
            user-select: none;
            touch-action: manipulation;
            box-shadow:
                0 14px 22px rgba(0, 0, 0, 0.38),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .tile:active {
            box-shadow: 0 8px 14px rgba(0, 0, 0, 0.32), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .tile-inner {
            height: 100%;
            width: 100%;
            border-radius: inherit;
            display: grid;
            place-items: center;
            font-variant-numeric: tabular-nums;
            background:
                radial-gradient(120px 80px at 30% 20%, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0.05) 60%, rgba(0, 0, 0, 0) 70%),
                linear-gradient(160deg, rgba(99, 102, 241, 0.92), rgba(14, 165, 233, 0.85));
            border: 1px solid rgba(255, 255, 255, 0.14);
        }

        .tile[aria-disabled="true"] {
            pointer-events: none;
            opacity: 0.65;
        }

        @media (prefers-reduced-motion: reduce) {
            .tile {
                transition: none;
            }

            .confetti {
                display: none !important;
            }
        }

        @keyframes nudge {
            0% {
                transform: translate(var(--x), var(--y));
            }

            25% {
                transform: translate(calc(var(--x) + 8%), var(--y));
            }

            50% {
                transform: translate(calc(var(--x) - 6%), var(--y));
            }

            75% {
                transform: translate(calc(var(--x) + 4%), var(--y));
            }

            100% {
                transform: translate(var(--x), var(--y));
            }
        }

        .nudge {
            animation: nudge 180ms ease;
        }

        .kbd {
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.06);
            padding: 0.1rem 0.45rem;
            border-radius: 0.5rem;
            font-variant-numeric: tabular-nums;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12);
        }
    </style>
</head>

<body class="min-h-screen bg-slate-950 text-slate-100">
    <div class="mx-auto max-w-3xl px-4 py-10">
        <header class="flex flex-col gap-3 md:flex-row md:items-end md:justify-between">
            <div>
                <h1 class="text-3xl md:text-4xl font-semibold tracking-tight">15-Puzzle</h1>
                <p class="mt-1 text-sm text-slate-300">
                    Slide tiles into the empty space. Use clicks/taps or arrow keys.
                    <span class="hidden sm:inline">(
                        <span class="kbd">↑</span> <span class="kbd">↓</span> <span class="kbd">←</span> <span
                            class="kbd">→</span>
                        moves the blank.)
                    </span>
                </p>
            </div>
            <div class="flex flex-wrap gap-2">
                <button id="shuffleBtn"
                    class="rounded-xl bg-indigo-500/90 px-4 py-2 text-sm font-semibold text-white shadow hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-300">
                    Shuffle
                </button>
                <button id="resetBtn"
                    class="rounded-xl bg-white/10 px-4 py-2 text-sm font-semibold text-white shadow hover:bg-white/15 focus:outline-none focus:ring-2 focus:ring-white/30">
                    Reset
                </button>
            </div>
        </header>

        <section class="mt-6 grid grid-cols-2 gap-3 md:grid-cols-4">
            <div class="rounded-2xl bg-white/5 p-4 ring-1 ring-white/10">
                <div class="text-xs uppercase tracking-wide text-slate-300">Moves</div>
                <div id="movesEl" class="mt-1 text-2xl font-semibold tabular-nums">0</div>
            </div>
            <div class="rounded-2xl bg-white/5 p-4 ring-1 ring-white/10">
                <div class="text-xs uppercase tracking-wide text-slate-300">Time</div>
                <div id="timeEl" class="mt-1 text-2xl font-semibold tabular-nums">00:00</div>
            </div>
            <div class="rounded-2xl bg-white/5 p-4 ring-1 ring-white/10">
                <div class="text-xs uppercase tracking-wide text-slate-300">Best (time)</div>
                <div id="bestTimeEl" class="mt-1 text-2xl font-semibold tabular-nums">—</div>
            </div>
            <div class="rounded-2xl bg-white/5 p-4 ring-1 ring-white/10">
                <div class="text-xs uppercase tracking-wide text-slate-300">Best (moves)</div>
                <div id="bestMovesEl" class="mt-1 text-2xl font-semibold tabular-nums">—</div>
            </div>
        </section>

        <main class="mt-6 flex flex-col items-center gap-4">
            <div class="w-full flex items-center justify-between gap-3">
                <div class="text-sm text-slate-300">
                    <span class="font-medium text-slate-200">Tip:</span> aim for minimal moves.
                </div>
                <div class="text-sm text-slate-300" aria-live="polite" id="statusEl"></div>
            </div>

            <div class="board ring-1 ring-white/10" id="board" aria-label="15 puzzle board" role="application"
                tabindex="0">
                <div class="grid-lines"></div>
                <!-- tiles injected here -->
            </div>

            <div class="w-full max-w-xl text-xs text-slate-400 leading-relaxed">
                Solvable shuffles only. Timer starts on your first move after shuffling.
                Press <span class="kbd">Shuffle</span> anytime for a new puzzle.
            </div>
        </main>
    </div>

    <!-- Win modal -->
    <div id="winModal" class="fixed inset-0 hidden items-center justify-center p-4">
        <div class="absolute inset-0 bg-black/70"></div>
        <div class="relative w-full max-w-md rounded-2xl bg-slate-900/90 p-6 ring-1 ring-white/15 backdrop-blur">
            <h2 class="text-2xl font-semibold">Solved!</h2>
            <p class="mt-2 text-sm text-slate-300">Nice work. Here are your results:</p>
            <div class="mt-4 grid grid-cols-2 gap-3">
                <div class="rounded-xl bg-white/5 p-4 ring-1 ring-white/10">
                    <div class="text-xs uppercase tracking-wide text-slate-300">Moves</div>
                    <div id="winMovesEl" class="mt-1 text-2xl font-semibold tabular-nums">0</div>
                </div>
                <div class="rounded-xl bg-white/5 p-4 ring-1 ring-white/10">
                    <div class="text-xs uppercase tracking-wide text-slate-300">Time</div>
                    <div id="winTimeEl" class="mt-1 text-2xl font-semibold tabular-nums">00:00</div>
                </div>
            </div>
            <div id="bestNoteEl" class="mt-3 text-sm text-emerald-300"></div>
            <div class="mt-5 flex flex-wrap justify-end gap-2">
                <button id="closeWinBtn"
                    class="rounded-xl bg-white/10 px-4 py-2 text-sm font-semibold text-white hover:bg-white/15 focus:outline-none focus:ring-2 focus:ring-white/30">
                    Close
                </button>
                <button id="playAgainBtn"
                    class="rounded-xl bg-indigo-500/90 px-4 py-2 text-sm font-semibold text-white hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-300">
                    Shuffle & Play
                </button>
            </div>
        </div>
    </div>

    <canvas id="confetti" class="confetti fixed inset-0 pointer-events-none hidden"></canvas>

    <script>
        // 15-puzzle implementation (4x4)
        const SIZE = 4;
        const GOAL = [...Array(SIZE * SIZE - 1).keys()].map(i => i + 1).concat([0]);

        const els = {
            board: document.getElementById('board'),
            shuffleBtn: document.getElementById('shuffleBtn'),
            resetBtn: document.getElementById('resetBtn'),
            movesEl: document.getElementById('movesEl'),
            timeEl: document.getElementById('timeEl'),
            statusEl: document.getElementById('statusEl'),
            bestTimeEl: document.getElementById('bestTimeEl'),
            bestMovesEl: document.getElementById('bestMovesEl'),
            winModal: document.getElementById('winModal'),
            winMovesEl: document.getElementById('winMovesEl'),
            winTimeEl: document.getElementById('winTimeEl'),
            bestNoteEl: document.getElementById('bestNoteEl'),
            closeWinBtn: document.getElementById('closeWinBtn'),
            playAgainBtn: document.getElementById('playAgainBtn'),
            confetti: document.getElementById('confetti'),
        };

        const storageKeys = {
            bestTimeMs: 'p15_bestTimeMs_v1',
            bestMoves: 'p15_bestMoves_v1',
        };

        let state = GOAL.slice();
        let moves = 0;
        let started = false;
        let solved = true;
        let startTs = 0;
        let elapsedMs = 0;
        let timerId = null;

        // Pre-create tile elements so moving is animated via transform.
        const tileButtons = new Map();

        function pad2(n) { return String(n).padStart(2, '0'); }

        function formatTime(ms) {
            const totalSec = Math.floor(ms / 1000);
            const m = Math.floor(totalSec / 60);
            const s = totalSec % 60;
            return `${pad2(m)}:${pad2(s)}`;
        }

        function getBest() {
            const bestTimeMs = Number(localStorage.getItem(storageKeys.bestTimeMs) ?? '0') || 0;
            const bestMoves = Number(localStorage.getItem(storageKeys.bestMoves) ?? '0') || 0;
            return { bestTimeMs, bestMoves };
        }

        function setBest({ bestTimeMs, bestMoves }) {
            if (bestTimeMs) localStorage.setItem(storageKeys.bestTimeMs, String(bestTimeMs));
            if (bestMoves) localStorage.setItem(storageKeys.bestMoves, String(bestMoves));
            renderBest();
        }

        function renderBest() {
            const { bestTimeMs, bestMoves } = getBest();
            els.bestTimeEl.textContent = bestTimeMs ? formatTime(bestTimeMs) : '—';
            els.bestMovesEl.textContent = bestMoves ? String(bestMoves) : '—';
        }

        function stopTimer() {
            if (timerId) {
                clearInterval(timerId);
                timerId = null;
            }
            started = false;
        }

        function startTimerIfNeeded() {
            if (started) return;
            started = true;
            startTs = performance.now() - elapsedMs;
            timerId = setInterval(() => {
                elapsedMs = performance.now() - startTs;
                els.timeEl.textContent = formatTime(elapsedMs);
            }, 125);
        }

        function resetStats() {
            moves = 0;
            elapsedMs = 0;
            els.movesEl.textContent = '0';
            els.timeEl.textContent = '00:00';
            els.statusEl.textContent = '';
            stopTimer();
        }

        function isSolved(arr) {
            for (let i = 0; i < GOAL.length; i++) if (arr[i] !== GOAL[i]) return false;
            return true;
        }

        function inversions(arr) {
            const nums = arr.filter(x => x !== 0);
            let inv = 0;
            for (let i = 0; i < nums.length; i++) {
                for (let j = i + 1; j < nums.length; j++) {
                    if (nums[i] > nums[j]) inv++;
                }
            }
            return inv;
        }

        function blankRowFromBottom(arr) {
            const idx = arr.indexOf(0);
            const rowFromTop = Math.floor(idx / SIZE); // 0..3
            return SIZE - rowFromTop; // 1..4
        }

        function isSolvable(arr) {
            const inv = inversions(arr);
            if (SIZE % 2 === 1) {
                return inv % 2 === 0;
            }
            // Even grid: solvable if (blank row from bottom is even and inversions odd) OR (blank row from bottom is odd and inversions even)
            const brfb = blankRowFromBottom(arr);
            return (brfb % 2 === 0) ? (inv % 2 === 1) : (inv % 2 === 0);
        }

        function fisherYates(a) {
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }

        function newShuffledState() {
            const base = GOAL.slice();
            // Generate until solvable and not already solved.
            let attempts = 0;
            while (attempts++ < 5000) {
                const arr = fisherYates(base.slice());
                if (arr[0] === 0) continue; // small bias to avoid boring start
                if (isSolvable(arr) && !isSolved(arr)) return arr;
            }
            // Fallback: do random valid moves from goal.
            let arr = GOAL.slice();
            for (let k = 0; k < 200; k++) {
                const b = arr.indexOf(0);
                const r = Math.floor(b / SIZE), c = b % SIZE;
                const neighbors = [];
                if (r > 0) neighbors.push(b - SIZE);
                if (r < SIZE - 1) neighbors.push(b + SIZE);
                if (c > 0) neighbors.push(b - 1);
                if (c < SIZE - 1) neighbors.push(b + 1);
                const pick = neighbors[Math.floor(Math.random() * neighbors.length)];
                [arr[b], arr[pick]] = [arr[pick], arr[b]];
            }
            if (isSolved(arr)) [arr[15], arr[14]] = [arr[14], arr[15]];
            return arr;
        }

        function indexToRC(idx) {
            return { r: Math.floor(idx / SIZE), c: idx % SIZE };
        }

        function isAdjacent(i, j) {
            const a = indexToRC(i);
            const b = indexToRC(j);
            return (a.r === b.r && Math.abs(a.c - b.c) === 1) || (a.c === b.c && Math.abs(a.r - b.r) === 1);
        }

        function moveTileByIndex(tileIndex, { fromInput = 'pointer' } = {}) {
            if (solved) return false;
            const blankIndex = state.indexOf(0);
            if (!isAdjacent(tileIndex, blankIndex)) return false;

            // start timer on first actual move
            startTimerIfNeeded();

            [state[tileIndex], state[blankIndex]] = [state[blankIndex], state[tileIndex]];
            moves++;
            els.movesEl.textContent = String(moves);

            renderTiles();

            if (isSolved(state)) {
                onSolved();
            } else {
                els.statusEl.textContent = fromInput === 'keyboard' ? 'Moved with keyboard.' : '';
            }

            return true;
        }

        function nudgeTile(val) {
            const btn = tileButtons.get(val);
            if (!btn) return;
            const idx = state.indexOf(val);
            const { r, c } = indexToRC(idx);
            btn.style.setProperty('--x', `${c * 100}%`);
            btn.style.setProperty('--y', `${r * 100}%`);
            btn.classList.remove('nudge');
            // Force reflow
            void btn.offsetWidth;
            btn.classList.add('nudge');
        }

        function onSolved() {
            solved = true;
            stopTimer();

            els.statusEl.textContent = 'Solved!';

            els.winMovesEl.textContent = String(moves);
            els.winTimeEl.textContent = formatTime(elapsedMs);

            const { bestTimeMs, bestMoves } = getBest();
            let improved = false;
            let note = '';

            // Update bests: time primary, moves secondary. Also store best moves independently.
            if (!bestTimeMs || elapsedMs < bestTimeMs) {
                improved = true;
                note = 'New best time!';
                setBest({ bestTimeMs: elapsedMs, bestMoves: bestMoves || 0 });
            }
            if (!bestMoves || moves < bestMoves) {
                improved = true;
                note = note ? (note + ' Also new best moves!') : 'New best moves!';
                setBest({ bestTimeMs: Number(localStorage.getItem(storageKeys.bestTimeMs) || 0) || bestTimeMs || 0, bestMoves: moves });
            }

            els.bestNoteEl.textContent = improved ? note : '';

            showWinModal();
            launchConfetti();
        }

        function showWinModal() {
            els.winModal.classList.remove('hidden');
            els.winModal.classList.add('flex');
            els.closeWinBtn.focus();
        }

        function hideWinModal() {
            els.winModal.classList.add('hidden');
            els.winModal.classList.remove('flex');
            els.bestNoteEl.textContent = '';
        }

        function ensureTilesExist() {
            // Create 15 tile buttons once.
            if (tileButtons.size) return;
            for (let v = 1; v <= 15; v++) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'tile focus:outline-none focus:ring-2 focus:ring-white/30';
                btn.setAttribute('aria-label', `Tile ${v}`);
                btn.dataset.value = String(v);

                const inner = document.createElement('div');
                inner.className = 'tile-inner text-2xl md:text-3xl font-bold text-white';
                inner.textContent = String(v);
                btn.appendChild(inner);

                btn.addEventListener('click', () => {
                    const idx = state.indexOf(v);
                    const ok = moveTileByIndex(idx, { fromInput: 'pointer' });
                    if (!ok) nudgeTile(v);
                });

                tileButtons.set(v, btn);
                els.board.appendChild(btn);
            }
        }

        function renderTiles() {
            ensureTilesExist();
            // Place tiles by updating transform.
            for (let v = 1; v <= 15; v++) {
                const idx = state.indexOf(v);
                const { r, c } = indexToRC(idx);
                const btn = tileButtons.get(v);
                // translate percentages are relative to the tile itself; 100% equals one cell.
                btn.style.setProperty('--x', `${c * 100}%`);
                btn.style.setProperty('--y', `${r * 100}%`);
                btn.style.transform = `translate(${c * 100}%, ${r * 100}%)`;
                btn.setAttribute('aria-disabled', solved ? 'true' : 'false');
            }
        }

        function setState(arr, { announce = '' } = {}) {
            state = arr.slice();
            solved = isSolved(state);
            renderTiles();
            if (announce) els.statusEl.textContent = announce;
        }

        function doShuffle() {
            hideWinModal();
            resetStats();
            const arr = newShuffledState();
            solved = false;
            setState(arr, { announce: 'Shuffled.' });
            // Focus board for keyboard play.
            els.board.focus({ preventScroll: true });
        }

        function doReset() {
            hideWinModal();
            resetStats();
            setState(GOAL, { announce: 'Reset to solved state.' });
            solved = true;
        }

        function moveBlankByDelta(dr, dc) {
            if (solved) return;
            const b = state.indexOf(0);
            const { r, c } = indexToRC(b);
            const nr = r + dr;
            const nc = c + dc;
            if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE) return;
            const tileIndex = nr * SIZE + nc; // tile to swap with blank
            moveTileByIndex(tileIndex, { fromInput: 'keyboard' });
        }

        function onKeyDown(e) {
            const key = e.key;
            // Only handle when board focused OR modal open? We'll ignore when typing in inputs (none here)
            if (els.winModal.classList.contains('flex')) {
                if (key === 'Escape') hideWinModal();
                return;
            }
            if (key === 'ArrowUp') { e.preventDefault(); moveBlankByDelta(-1, 0); }
            else if (key === 'ArrowDown') { e.preventDefault(); moveBlankByDelta(1, 0); }
            else if (key === 'ArrowLeft') { e.preventDefault(); moveBlankByDelta(0, -1); }
            else if (key === 'ArrowRight') { e.preventDefault(); moveBlankByDelta(0, 1); }
            else if (key === ' ' || key === 'Enter') {
                // Space/Enter to shuffle when board focused
                if (document.activeElement === els.board) {
                    e.preventDefault();
                    doShuffle();
                }
            } else if (key === 'Escape') {
                hideWinModal();
            }
        }

        // Confetti
        function launchConfetti() {
            const canvas = els.confetti;
            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            const resize = () => {
                canvas.width = Math.floor(window.innerWidth * dpr);
                canvas.height = Math.floor(window.innerHeight * dpr);
                canvas.style.width = window.innerWidth + 'px';
                canvas.style.height = window.innerHeight + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            };
            resize();

            canvas.classList.remove('hidden');

            const colors = ['#60a5fa', '#a78bfa', '#34d399', '#fbbf24', '#fb7185', '#22d3ee'];
            const pieces = Array.from({ length: 140 }, () => {
                const size = 6 + Math.random() * 8;
                return {
                    x: Math.random() * window.innerWidth,
                    y: -20 - Math.random() * window.innerHeight * 0.25,
                    vx: (Math.random() - 0.5) * 3.0,
                    vy: 2.0 + Math.random() * 4.6,
                    g: 0.07 + Math.random() * 0.06,
                    r: Math.random() * Math.PI,
                    vr: (Math.random() - 0.5) * 0.25,
                    w: size,
                    h: size * (0.55 + Math.random() * 0.7),
                    c: colors[Math.floor(Math.random() * colors.length)],
                    a: 0.9,
                };
            });

            const start = performance.now();
            const duration = 1600;

            function frame(now) {
                const t = now - start;
                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

                for (const p of pieces) {
                    p.vy += p.g;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.r += p.vr;

                    // fade out near end
                    if (t > duration * 0.7) p.a = Math.max(0, 0.9 * (1 - (t - duration * 0.7) / (duration * 0.3)));

                    ctx.save();
                    ctx.globalAlpha = p.a;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.r);
                    ctx.fillStyle = p.c;
                    ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
                    ctx.restore();
                }

                if (t < duration) {
                    requestAnimationFrame(frame);
                } else {
                    canvas.classList.add('hidden');
                }
            }

            const onResize = () => resize();
            window.addEventListener('resize', onResize, { passive: true, once: true });
            requestAnimationFrame(frame);
        }

        // Wiring
        els.shuffleBtn.addEventListener('click', doShuffle);
        els.resetBtn.addEventListener('click', doReset);
        els.closeWinBtn.addEventListener('click', () => { hideWinModal(); els.board.focus({ preventScroll: true }); });
        els.playAgainBtn.addEventListener('click', doShuffle);

        // Allow key controls anywhere, but board is focusable for better UX.
        window.addEventListener('keydown', onKeyDown);

        // Initialize
        renderBest();
        ensureTilesExist();
        doReset();
        // Start in a playable state automatically:
        doShuffle();
    </script>
</body>

</html>