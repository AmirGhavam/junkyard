<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15 Puzzle Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        body {
            font-family: 'Poppins', sans-serif;
        }

        .tile {
            transition: all 0.15s ease-out;
            user-select: none;
        }

        .tile:not(.empty):hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }

        .tile:not(.empty):active {
            transform: scale(0.98);
        }

        .solved-animation {
            animation: celebrate 0.6s ease-in-out;
        }

        @keyframes celebrate {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .confetti {
            position: fixed;
            pointer-events: none;
            animation: fall 3s linear forwards;
        }

        @keyframes fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }
    </style>
</head>

<body
    class="min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-800 flex items-center justify-center p-4">
    <div class="bg-white/10 backdrop-blur-lg rounded-3xl p-8 shadow-2xl border border-white/20">
        <h1 class="text-4xl font-bold text-center text-white mb-6 drop-shadow-lg">15 Puzzle</h1>

        <!-- Stats Bar -->
        <div class="flex justify-between items-center mb-6 px-2">
            <div class="text-center">
                <p class="text-white/60 text-sm uppercase tracking-wider">Moves</p>
                <p id="moveCounter" class="text-3xl font-bold text-white">0</p>
            </div>
            <div class="text-center">
                <p class="text-white/60 text-sm uppercase tracking-wider">Time</p>
                <p id="timer" class="text-3xl font-bold text-white font-mono">00:00</p>
            </div>
        </div>

        <!-- Puzzle Grid -->
        <div id="puzzleGrid" class="grid grid-cols-4 gap-2 mb-6 p-3 bg-black/20 rounded-2xl">
            <!-- Tiles will be generated here -->
        </div>

        <!-- Controls -->
        <div class="flex gap-4 justify-center">
            <button id="shuffleBtn"
                class="px-6 py-3 bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-400 hover:to-orange-400 text-white font-semibold rounded-xl shadow-lg transition-all hover:scale-105 active:scale-95">
                ðŸ”€ Shuffle
            </button>
            <button id="resetBtn"
                class="px-6 py-3 bg-gradient-to-r from-emerald-500 to-teal-500 hover:from-emerald-400 hover:to-teal-400 text-white font-semibold rounded-xl shadow-lg transition-all hover:scale-105 active:scale-95">
                ðŸ”„ Reset
            </button>
        </div>

        <!-- Win Message -->
        <div id="winMessage" class="hidden mt-6 text-center">
            <p class="text-2xl font-bold text-yellow-300 animate-pulse">ðŸŽ‰ Congratulations! ðŸŽ‰</p>
            <p class="text-white/80 mt-2">You solved the puzzle!</p>
        </div>
    </div>

    <script>
        const GRID_SIZE = 4;
        const TOTAL_TILES = GRID_SIZE * GRID_SIZE;

        let tiles = [];
        let emptyIndex = TOTAL_TILES - 1;
        let moveCount = 0;
        let timerInterval = null;
        let startTime = null;
        let isPlaying = false;
        let isSolved = false;

        const puzzleGrid = document.getElementById('puzzleGrid');
        const moveCounter = document.getElementById('moveCounter');
        const timerDisplay = document.getElementById('timer');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const resetBtn = document.getElementById('resetBtn');
        const winMessage = document.getElementById('winMessage');

        // Initialize the puzzle
        function initPuzzle() {
            tiles = [];
            for (let i = 1; i < TOTAL_TILES; i++) {
                tiles.push(i);
            }
            tiles.push(0); // Empty tile
            emptyIndex = TOTAL_TILES - 1;
            renderPuzzle();
        }

        // Render the puzzle grid
        function renderPuzzle() {
            puzzleGrid.innerHTML = '';
            tiles.forEach((tile, index) => {
                const tileElement = document.createElement('div');

                if (tile === 0) {
                    tileElement.className = 'tile empty w-18 h-18 sm:w-20 sm:h-20 rounded-xl';
                } else {
                    const hue = (tile * 24) % 360;
                    tileElement.className = 'tile w-18 h-18 sm:w-20 sm:h-20 rounded-xl flex items-center justify-center text-2xl font-bold text-white cursor-pointer shadow-lg';
                    tileElement.style.background = `linear-gradient(135deg, hsl(${hue}, 70%, 50%), hsl(${hue + 30}, 70%, 40%))`;
                    tileElement.textContent = tile;
                    tileElement.addEventListener('click', () => handleTileClick(index));
                }

                puzzleGrid.appendChild(tileElement);
            });
        }

        // Check if a tile can move
        function canMove(index) {
            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;
            const emptyRow = Math.floor(emptyIndex / GRID_SIZE);
            const emptyCol = emptyIndex % GRID_SIZE;

            const rowDiff = Math.abs(row - emptyRow);
            const colDiff = Math.abs(col - emptyCol);

            return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
        }

        // Handle tile click
        function handleTileClick(index) {
            if (isSolved) return;

            if (canMove(index)) {
                // Start timer on first move
                if (!isPlaying) {
                    startTimer();
                    isPlaying = true;
                }

                // Swap tiles
                [tiles[index], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[index]];
                emptyIndex = index;

                // Update move counter
                moveCount++;
                moveCounter.textContent = moveCount;

                // Re-render
                renderPuzzle();

                // Check for win
                if (checkWin()) {
                    handleWin();
                }
            }
        }

        // Check if puzzle is solved
        function checkWin() {
            for (let i = 0; i < TOTAL_TILES - 1; i++) {
                if (tiles[i] !== i + 1) return false;
            }
            return tiles[TOTAL_TILES - 1] === 0;
        }

        // Handle win condition
        function handleWin() {
            isSolved = true;
            stopTimer();
            winMessage.classList.remove('hidden');
            puzzleGrid.classList.add('solved-animation');
            createConfetti();
        }

        // Create confetti effect
        function createConfetti() {
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590', '#a855f7'];

            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.top = '-20px';
                    confetti.style.width = (Math.random() * 10 + 5) + 'px';
                    confetti.style.height = confetti.style.width;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                    document.body.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 4000);
                }, i * 50);
            }
        }

        // Shuffle the puzzle
        function shuffle() {
            // Reset state
            resetState();

            // Perform random valid moves to ensure solvability
            let shuffleMoves = 100 + Math.floor(Math.random() * 50);

            for (let i = 0; i < shuffleMoves; i++) {
                const validMoves = getValidMoves();
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                [tiles[randomMove], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[randomMove]];
                emptyIndex = randomMove;
            }

            // Make sure it's not already solved
            if (checkWin()) {
                shuffle();
                return;
            }

            renderPuzzle();
        }

        // Get all valid moves
        function getValidMoves() {
            const moves = [];
            const emptyRow = Math.floor(emptyIndex / GRID_SIZE);
            const emptyCol = emptyIndex % GRID_SIZE;

            // Up
            if (emptyRow > 0) moves.push(emptyIndex - GRID_SIZE);
            // Down
            if (emptyRow < GRID_SIZE - 1) moves.push(emptyIndex + GRID_SIZE);
            // Left
            if (emptyCol > 0) moves.push(emptyIndex - 1);
            // Right
            if (emptyCol < GRID_SIZE - 1) moves.push(emptyIndex + 1);

            return moves;
        }

        // Reset state
        function resetState() {
            stopTimer();
            moveCount = 0;
            moveCounter.textContent = '0';
            timerDisplay.textContent = '00:00';
            isPlaying = false;
            isSolved = false;
            winMessage.classList.add('hidden');
            puzzleGrid.classList.remove('solved-animation');
        }

        // Full reset
        function reset() {
            resetState();
            initPuzzle();
        }

        // Timer functions
        function startTimer() {
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            timerDisplay.textContent = `${minutes}:${seconds}`;
        }

        // Event listeners
        shuffleBtn.addEventListener('click', shuffle);
        resetBtn.addEventListener('click', reset);

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (isSolved) return;

            const emptyRow = Math.floor(emptyIndex / GRID_SIZE);
            const emptyCol = emptyIndex % GRID_SIZE;
            let targetIndex = -1;

            switch (e.key) {
                case 'ArrowUp':
                    if (emptyRow < GRID_SIZE - 1) targetIndex = emptyIndex + GRID_SIZE;
                    break;
                case 'ArrowDown':
                    if (emptyRow > 0) targetIndex = emptyIndex - GRID_SIZE;
                    break;
                case 'ArrowLeft':
                    if (emptyCol < GRID_SIZE - 1) targetIndex = emptyIndex + 1;
                    break;
                case 'ArrowRight':
                    if (emptyCol > 0) targetIndex = emptyIndex - 1;
                    break;
            }

            if (targetIndex >= 0) {
                e.preventDefault();
                handleTileClick(targetIndex);
            }
        });

        // Initialize and shuffle on load
        initPuzzle();
        shuffle();
    </script>
</body>

</html>